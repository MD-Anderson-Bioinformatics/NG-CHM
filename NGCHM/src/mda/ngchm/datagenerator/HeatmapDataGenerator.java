/*******************************************************************
 * CLASS: HeatmapDataGenerator
 *
 * This class is the driver for the heat map data generation process. 
 * import data matrix files are read in and clustered.  Data tiles, 
 * containing binary data representation of the matrix data are 
 * written out.  Finally, tile structure and column header json 
 * files are generated by the process.
 * 
 * Author: Mark Stucky
 * Date: December 14, 2015
 ******************************************************************/

package mda.ngchm.datagenerator;

import java.awt.Color;
import java.awt.Graphics; 
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.imageio.ImageIO;

import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.util.ArrayList;
import java.io.OutputStreamWriter;

import mda.ngchm.datagenerator.ImportData;
import static mda.ngchm.datagenerator.ImportConstants.*;


public class HeatmapDataGenerator {

	/*******************************************************************
	 * METHOD: main
	 *
	 * This method is the driver for the entire heat map data generation
	 * process.  
	 ******************************************************************/
	public static void main(String[] args) {
		String errMsg = processHeatMap(args);
		if ((errMsg != EMPTY) && (errMsg.contains("BUILD ERROR"))) {
			System.out.println( "ERROR in HeatmapDataGenerator e= "+ errMsg);
			System.exit(1);
		} else {
			System.exit(0);
		}
	}

	/*******************************************************************
	 * METHOD: processHeatMap
	 *
	 * An incoming JSON file is parsed to create the following
	 * data objects representing the heatmap to be generated:
	 * 1. ImportData - This object describes the entire map and holds
	 *                 all of the objects related to the map.
	 * 2. ImportFile - This object is generated for each data layer (matrix)
	 *                 data file input to the map.
	 * 3. ImportClass - This object is generated for each classification 
	 *                  (covariate) file input to the map.
	 * 4. ImportLayerData - This object is generated for each data level
	 * 					  (e.g. thumbnail, summary, etc) in the map.
	 * 5. ImportTileData - This object is generated for each data tile
	 *                   within an ImportDataLayer.
	 * 6. RowColData - This object is generated, one for rows and one for
	 *                 columns, in the map.
	 * 7. ColorMap - A colorMap object is generated for each ImportFile
	 *               and ImportClass in the map.
	 *               
	 * Once all of the above objects have been created for a heatmap, this
	 * method will generate tile files, containing binary matrix data, for
	 * each tile in the map.  Finally, the configuration JSON files 
	 * necessary for rendering the heatmap in the NGCHM viewer are 
	 * generated.
	 ******************************************************************/
	public static String processHeatMap(String[] args) {
		System.out.println("START Data Generator Heat Map Generation: " + new Date()); 
		String errMsg = EMPTY;
		       
		//Used to keep pdfBox warning messages out of the log (specifically for Galaxy)
		java.util.logging.Logger.getLogger("org.apache.pdfbox").setLevel(java.util.logging.Level.SEVERE);
		
		// Validate JSON configuration file
        try {     
        	validateConfigJson(new File(args[0]));
        } catch (Exception e) {
    		System.out.println("FATAL ERROR: Invalid heatmapProperties.JSON: " + new Date()); 
            return "BUILD ERROR: Invalid JSON Configuration.";
        } 

		// Create ImportData object for data matrix.  This object will 
		// contain subordinate objects for import layers and import tiles
		ImportData iData = null;
        try {
			iData =  new ImportData(args);
        } catch (Exception ex) {
			System.out.println("FATAL ERROR: Importing Heat Map Configuration Data. " + ex.getMessage());  
			return "BUILD ERROR: Importing Heat Map Configuration Data. " + ex.getMessage();
        }

		//Validate that all data layers are the same size.
        if (iData.matrixFiles.size() > 1) {
        	try {
            	MatrixValidator.validateDataLayersSize(iData.matrixFiles);
        	} catch (Exception ex) {
    			errMsg = "BUILD ERROR: Data Layer Input - " + ex.getMessage();
    			System.out.println(errMsg);  
    	        return errMsg;
        	}
        }

		ImportLayerData summaryLayer = null;
		try {
			for (int i=0; i < iData.matrixFiles.size(); i++) {
				summaryLayer = writeTileFiles(iData, i);
			}
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing Tile Data - " + ex.getMessage();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}

		//Create configuration files for heatmap viewer
		try {
			writeMapDataFile(iData, summaryLayer);
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing mapData.JSON Configuration File: " + ex.toString();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}
		try {
			writeMapConfigFile(iData);
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing mapConfig.JSON Configuration File: " + ex.toString();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}
		
		//Thumbnail PNG
        InputFile iFile = iData.matrixFiles.get(0);
		try {
    	    createTnHeatmapImg(iFile.getMap(), iData, iData.tnMatrix);
			buildTnThumbnail(iData);
		} catch (Exception e) {
			System.out.println("Error generating thumbnail image: " + e.toString());  
		}

		//Generate PDF
        if ((iData.generatePDF) && (iData.readMatrices.equals(YES))) {
        	boolean fullPDF = false;
			try {
	        	for (int i=0; i < iData.matrixFiles.size();i++) {
			        iFile = iData.matrixFiles.get(i);
			        if (iData.pdfMatrices !=null) {
			        	createSummaryImg(iFile.getMap(), iData, iData.pdfMatrices.get(i));
			        }
	        	}
		        int size = iData.pdfMatrices.get(0).length;
	        	for (int i=0; i < iData.rowData.classFiles.size();i++) {
	        		InputClass iClass = iData.rowData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.rowData.createTopItemsImg(iData.rowData.classArray.length - 1);
				size = iData.pdfMatrices.get(0)[0].length;
	        	for (int i=0; i < iData.colData.classFiles.size();i++) {
	        		InputClass iClass = iData.colData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.colData.createTopItemsImg(iData.colData.classArray.length - 1);
				PdfGenerator pGen = new PdfGenerator();
				if (iData.rowData.dendroMatrix != null) {
					iData.rowData.dendroImage = createRowDendroImg(iData, new Float(5.5));
				}
				if (iData.colData.dendroMatrix != null) {
					iData.colData.dendroImage = createColDendroImg(iData, new Float(5.5));
				}
				pGen.createHeatmapPDF(iData, fullPDF); 
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating PDF: " + ex.toString());  
				ex.printStackTrace();
			}
        } 
        if (iData.generateFullPDF) { 
        	boolean fullPDF = true;
			try {
	        	for (int i=0; i < iData.matrixFiles.size();i++) {
			        iFile = iData.matrixFiles.get(i);
			        if (iData.pdfMatrices !=null) {
			        	createDetailImg(iFile.getMap(), iData, iData.pdfMatrices.get(i));
			        }
	        	}
		        int size = iData.pdfMatrices.get(0).length;
	        	for (int i=0; i < iData.rowData.classFiles.size();i++) {
	        		InputClass iClass = iData.rowData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.rowData.createTopItemsImg(iData.rowData.classArray.length - 1);
				size = iData.pdfMatrices.get(0)[0].length;
	        	for (int i=0; i < iData.colData.classFiles.size();i++) {
	        		InputClass iClass = iData.colData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.colData.createTopItemsImg(iData.colData.classArray.length - 1);
				PdfGenerator pGen = new PdfGenerator();
				if (iData.rowData.dendroMatrix != null) {
					Float sizeTo = new Float( new Float(iData.rowData.dendroMatrix[0].length*5-1)/ new Float(120));  // mapWidth divided by 120 to get inch width of map. 120 is a bit of a fudge factor to try to figure out how many points per inch on the PDF
					iData.rowData.dendroImage = createRowDendroImg(iData, sizeTo);
				}
				if (iData.colData.dendroMatrix != null) {
					Float sizeTo = new Float( new Float((iData.colData.dendroMatrix[0].length*5-1))/ new Float(120));  // mapWidth divided by 120 to get inch width of map, x65% to get approximate size on page
					iData.colData.dendroImage = createColDendroImg(iData, sizeTo);
				}
				pGen.createHeatmapPDF(iData, fullPDF); 
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating PDF: " + ex.toString());  
				ex.printStackTrace();
			}
        }
		//Generate zipped .ngchm file
        if (iData.generateNGCHM) {
        	try {
        		zipDirectory(iData.outputDir, iData.chmName);
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating NGCHM zip file: " + ex.toString());  
				ex.printStackTrace();
			}
        }

    	//Generate combined .ngchm, js, embedded html file
        if (iData.generateHTML) {
        	try {
        		createHtmlHeatMap(iData.outputDir, iData.chmName);
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating NGCHM zip file: " + ex.toString());  
				ex.printStackTrace();
			}
        }
        
        if (iData.rowData.configWarnings.size() > 0) {
			for (int i=0;i<iData.rowData.configWarnings.size();i++) {
				errMsg = errMsg + iData.rowData.configWarnings.get(i) + "\n";
			}
		}
		if (iData.colData.configWarnings.size() > 0) {
			for (int i=0;i<iData.colData.configWarnings.size();i++) {
				errMsg = errMsg + iData.colData.configWarnings.get(i) + "\n";
			}
		}
		System.out.println("END Heat Map Generation: " + new Date()); 
		return errMsg;
	}
	
	/*******************************************************************
	 * METHOD: validateConfigJson
	 *
	 * This method parses the heatmapProperties JSON file to validate
	 * its contents. 
	 ******************************************************************/
	private static void validateConfigJson(File config) throws Exception {
		// Validate JSON configuration file
		FileReader configFile = new FileReader(config);
		try {     
	        JSONParser parser = new JSONParser();
	        parser.parse(configFile);
	        configFile.close();
	    } catch (FileNotFoundException ex) {
	        System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: heatmapProperties.JSON file not found." );
			System.out.println("If you are using Shaidy to generate the map, the file should be located in the Viewer directory."); 
			System.out.println("If you are using a server to supply the heat map to the data generator, the file should be located in the appropriate map directory in the defined mapLocation for your server."); 
			ex.printStackTrace();
	        throw ex;
	    } catch (IOException ex) {
	        System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: IO Exception reading heatmapProperties.JSON file.");
			System.out.println("The HeatmapProperties.json file could not be read and may be corrupted."); 
			System.out.println("If you are using Shaidy to generate the map, you may retrieve the file from you Viewer directory and run it through an online JSON parser (e.g. jsonlint.com) to diagnose the JSON file."); 
			System.out.println("If you are using a server to supply the heat map to the data generator, check the appropriate map directory in the defined mapLocation for your server."); 
			ex.printStackTrace();
	        throw ex;
	   } catch (ParseException ex) {
			System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: Invalid Heatmap Configuration."); 
			System.out.println("The HeatmapProperties.json file could not be parsed."); 
			System.out.println("If you are using Shaidy to generate the map, you may retrieve the file from your Viewer directory and run it through an online JSON parser (e.g. jsonlint.com) to diagnose the JSON file."); 
			System.out.println("If you are using a server to supply the heat map to the data generator, check the appropriate map directory in the defined mapLocation for your server."); 
			System.out.println("If the stack trace contains a reference to an unexpected character, search for that character in the HeatmapProperties.json file. It may be outside of node or value quotation marks.");
			System.out.println("You may also have either node parameters or values that contain single quotes instead of double which is invalid.");
	        ex.printStackTrace();
	        throw ex;
	   } finally {
		   configFile.close();
		   configFile = null;
	   }
	}
	
	/*====================================================================
	 * BEGIN: DATA TILE FILE WRITING METHODS
	 *
	 * The methods that follow are concerned with writing out data tile
	 * output files to the various tile "level" output directories.
	 *====================================================================*/

	/*******************************************************************
	 * METHOD: writeTileFiles
	 *
	 * This method writes out all data tile files for a map by iterating 
	 * thru the ImportDataLayers and calling the writeTileFile method for
	 * each tile in each layer. 
	 ******************************************************************/
	private static ImportLayerData writeTileFiles(ImportData iData, int position) throws Exception {
		ImportLayerData summaryLayer = null;
		try {
			// Loop thru ImportData object processing for each ImportDataLayer
			InputFile iFile = iData.matrixFiles.get(position);
			float[][] clusteredMatrix = iFile.getReorderedInputMatrix(iData.rowData, iData.colData);

			if (iFile.map.colors.isEmpty()) {
				iFile.map = ColorMapGenerator.getDefaultMapColors(iFile, clusteredMatrix);
			}
			if (iData.generateFullPDF) {
				iFile.createDistributionLegendImg(clusteredMatrix);
			}
			ArrayList<ImportLayerData> iLayers = iFile.importLayers;
			for (int i=0; i < iLayers.size(); i++) {
				ImportLayerData ilData = iLayers.get(i);
				// Create thumbnail float value array for ONLY the first data layer processed.
				if (ilData.layer.equals(LAYER_THUMBNAIL)) {
					if (iFile.position.equals("DataLayer1")) {
						iData.tnMatrix = new Float[ilData.rowsPerTile][ilData.colsPerTile];
					}
					if (!iFile.hasSummary) {
						iData.pdfMatrices.add(new Float[ilData.rowsPerTile][ilData.colsPerTile]);
					}
				}
				if (ilData.layer.equals(LAYER_SUMMARY) && (iData.generatePDF)) {
					iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
				}
				else if (iData.generateFullPDF) {
					// if it has detail tiles, use those, if not revert to summary. if not summary, then thumbnail
					if (ilData.layer.equals(LAYER_THUMBNAIL) && !iFile.hasSummary) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					} else if (ilData.layer.equals(LAYER_SUMMARY) && !iFile.hasDetail) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					} else if (ilData.layer.equals(LAYER_DETAIL)) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					}
				}
				
				if (ilData.layer.equals(LAYER_SUMMARY)) {
					summaryLayer = ilData;
				}
				String dlDir = "dl"+(position+1);
		    	File dataDir = new File(iData.outputDir+File.separator+dlDir+File.separator+ilData.layer);
		    	if (!dataDir.exists()) {
		    		if ((iData.writeTiles.equals(NO)) || (iData.writeTiles.equals(NO))) {
		    			System.out.println("BUILD ERROR: write_tiles or read_matrices is set to NO and tile directory does not exist.  Cannot continue processing heat map.");
		    			return null;
		    		}
		    	}
		    	
				if (iData.readMatrices.equals(YES)) {
					// Within each ImportDataLayer, loop thru each of its 
					// ImportTileData objects writing out a tile for each
					for (int j=0; j < ilData.importTiles.size(); j++){
						ImportTileData itData = ilData.importTiles.get(j);
						writeTileFile(iData, ilData, itData, position, clusteredMatrix);
					}
				}
			}
			if (DEBUG) {
				writeClusteredDebugFile(iData, iFile, clusteredMatrix, (position+1));
			}
	    	clusteredMatrix = null;
	    	System.gc();
		} catch (Exception ex) {
	    	System.out.println("Exception writing tile files: "+ ex.toString());
			throw ex;
		}
		return summaryLayer;
	}
	
	/*******************************************************************
	 * METHOD: writeTileFile
	 *
	 * This method writes out individual data tile files by iterating 
	 * thru the data matrix string array, stored on the ImportData object,
	 * and writing out individual binary float values using the ImportLayerData 
	 * and ImportTileData objects as a guideline.
	 ******************************************************************/
	private static void writeTileFile(ImportData iData, ImportLayerData ilData, ImportTileData itData, int position, float[][] clusteredMatrix) throws Exception {
		BufferedOutputStream write = null;
	    try {
			InputFile iFile = iData.matrixFiles.get(position);
			String dlDir = "dl"+(position+1);

			//If tile destination dir does not exist, create directory.
	    	File dataDir = new File(iData.outputDir+File.separator+dlDir+File.separator+ilData.layer);
	    	if (!dataDir.exists()) {
	    		dataDir.mkdirs();
	    	} 
//	    	boolean writeTiles = true;
//			File tileFile = new File(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName);
//			if (tileFile.exists()) {
//				writeTiles = getOrderDendroFileDate(iData) < tileFile.lastModified() ? false : true;
//			}
	        
			if (iData.writeTiles.equals(YES)) {
				write = new BufferedOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName));
			}
			int rowStart = itData.rowStartPos, rowEnd = itData.rowEndPos;
			int colStart = itData.colStartPos, colEnd = itData.colEndPos; 
			int rowInterval = ilData.rowInterval, colInterval = ilData.colInterval;
			int nextColWrite = 0;
			int nextRowWrite = getNextRowWrite(ilData, rowStart);
			int nextCol = getNextColWrite(ilData, colStart);
			DataOutputStream writeRow=null;
			if (DEBUG) { writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName + TXT_FILE));  }//For debugging: writes out file
			int rowctr = 0;
			int colctr = 0;
			for (int row = rowStart; row < rowEnd; row++) {
				if (row == nextRowWrite) {
					nextColWrite = nextCol;
					String valprint = null;
					if (DEBUG) { valprint = Integer.toString(row); } //For debugging: writes out file
					for (int col = colStart; col < colEnd; col++) {
						if (col == nextColWrite) {
							float v = getMatrixValue(iData,ilData,iFile,row,col,clusteredMatrix); 
							if (ilData.layer.equals(LAYER_THUMBNAIL)) {
								if (iFile.position.equals("DataLayer1")) {
									iData.tnMatrix[rowctr][colctr] = v;
								}
								if (!iFile.hasSummary) {
									iData.pdfMatrices.get(position)[rowctr][colctr] = v;
								}
							}
							if (ilData.layer.equals(LAYER_SUMMARY) && (iData.generatePDF)) {
								int rowPos = itData.rowStartPos == 1 ? rowctr : ilData.rowsPerTile + rowctr;
								int colPos = itData.colStartPos == 1 ? colctr : ilData.colsPerTile + colctr;
								iData.pdfMatrices.get(position)[rowPos][colPos] = v;
							} else if (iData.generateFullPDF) {
								if (ilData.layer.equals(LAYER_THUMBNAIL) && !iFile.hasSummary) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if (ilData.layer.equals(LAYER_SUMMARY) && !iFile.hasDetail) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : ilData.rowsPerTile + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : ilData.colsPerTile + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if (ilData.layer.equals(LAYER_DETAIL)) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart - 1 + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart - 1 + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if ((ilData.layer.equals(LAYER_RIBBONVERT) || ilData.layer.equals(LAYER_RIBBONHORIZ)) && !iFile.hasDetail) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								}
							}
							byte f[] = ByteBuffer.allocate(4).putFloat(v).array();
							if (DEBUG) { valprint = valprint + TAB + v; } //For debugging: writes out file
							if (iData.writeTiles.equals(YES)) {
								write.write(f, 3, 1);
								write.write(f, 2, 1);
								write.write(f, 1, 1);
								write.write(f, 0, 1); 
							}
							nextColWrite += colInterval;
							colctr++;
						}
					}
					if (DEBUG) { 
						valprint = valprint + "\r\n";  //For debugging: writes out file
						writeRow.writeChars(valprint); 
					} 
					nextRowWrite += rowInterval;
					rowctr++;
					colctr = 0;
				} 
			}
	    	if (DEBUG) { writeRow.close(); } //For debugging: writes out file
	    } catch (NumberFormatException ex) {
	    	System.out.println("Exception in HeatmapDataGenerator.writeTileFile: Non-numeric data found in matrix "+ ex.toString());
	       throw ex;
	    } finally {
			if (write != null) {
				write.close();
			}
	    }
	}
	
	/*******************************************************************
	 * METHOD: getMatrixValue
	 *
	 * This method retrieves the matrix value to be written out to a given
	 * data tile. If the sampling method of "sample" is being used, the 
	 * value associated with the row/col passed in is returned. If the 
	 * sampling method is "average" or "predominance" an array is populated 
	 * containing all of the values in the range of the current value based
	 * upon the row/col intervals.  If the method is average, the value 
	 * returned will be the average of all values in the array. If the 
	 * method is "predominance", the value that re-occurs the most in the
	 * array is returned. 
	 ******************************************************************/
	private static float getMatrixValue(ImportData iData, ImportLayerData ilData, InputFile iFile, int row, int col, float[][] clusteredMatrix) throws Exception
	{  
	  float value = 0;
	  if (iFile.summaryMethod.equals(METHOD_SAMPLE)) {
		  value = clusteredMatrix[row][col];
	  }	else  {
		  int rowInter = ilData.rowInterval;
		  int colInter = ilData.colInterval;
		  if (rowInter+colInter == 2) {
			  value = clusteredMatrix[row][col];
		  } else {
			  //We must check if we are going past the max row/cols and adjust the 
			  //boundary for our loop AND the interval value that will be used for averaging.
			  int rowBoundary = row+ilData.rowInterval;
			  int colBoundary = col+ilData.colInterval;
			  if (rowBoundary>= clusteredMatrix.length) {
				  rowBoundary = clusteredMatrix.length;
				  rowInter = rowBoundary - row;
			  }
			  if (colBoundary>= clusteredMatrix[0].length) {
				  colBoundary = clusteredMatrix[0].length;
				  colInter = colBoundary - col;
			  }
			  int combInter = (rowInter*colInter);
			  float[] valArr = new float[combInter];
			  int valArrIdx = 0;
			  // Grab all values in the prescribed bounded range and place them in an array
			  for (int i = row; i < rowBoundary;i++) {
				  for (int j = col; j < colBoundary;j++) {
					  valArr[valArrIdx] = clusteredMatrix[i][j];
					  valArrIdx++;
				  }
			  }
			  if (iFile.summaryMethod.equals(METHOD_AVERAGE)) {
				  value = getAverageValue(valArr, combInter);  
			  } else if (iFile.summaryMethod.equals(METHOD_MODE)) {
				  value = getPredominantValue(valArr);
			  }
		  }
	  }	
	  return value;  
	}
	
	/*******************************************************************
	 * METHOD: getAverageValue
	 *
	 * This method iterates thru the array passed, in summing all of the
	 * values contained therein. That value is then divided by the 
	 * combined row/col interval.  HIGH VALUES are factored out UNLESS
	 * they represent every data element in the block being averaged.
	 ******************************************************************/
	private static float getAverageValue(float[] array, int combInter) throws Exception {
		float retVal = 0;
		float value = 0;
		boolean allCut = true;
		// sum the values in the array
		for (int k = 0; k < array.length; k++) {
			if ((array[k] != MAX_VALUES) && (array[k] != MIN_VALUES)) {
				value = value + array[k];
			} else {
				if (array[k] != MIN_VALUES) {
					allCut = false;
				}
				combInter--;
			}
		}
		//If at least one value in the array is not a max/cut value, average and return.
		if (combInter != 0) {
			retVal = value / combInter;
		} else {
			//If all values to be averaged are cut values, return the cut value
			if (allCut) {
				retVal =  MIN_VALUES;
			} else {
				retVal =  MAX_VALUES;
			}
		}
		return retVal;
	}
	
	/*******************************************************************
	 * METHOD: getPredominantValue
	 *
	 * This method iterates thru the array passed in, summing the 
	 * number occurrences of each value in the array and returns the 
	 * value with the most occurrences. If more than one value occurs the 
	 * same amount of times, the first value encountered is returned.
	 ******************************************************************/
	private static float getPredominantValue(float[] array) throws Exception {
		float value = 0;
        ArrayList<Float> distinctVals = new ArrayList<>();
        // loop original array adding distinct values to ArrayList
        for(int i= 0; i< array.length; i++) {
            boolean found = false;
            float iVal = array[i];
            // loop distinct values to see if current value already exists
            for (int v =0; v<distinctVals.size(); v++) {
                if(distinctVals.get(v)==iVal) {
                  found = true;
                  break;
                }
            }
            // add distinct value to ArrayList is not found
            if (!found) {
            	distinctVals.add(iVal);
            }
        }
        // create array for storing counts based on number of distinct values
        int [] arrayIndex= new int[distinctVals.size()];
        // loop distinct values array
        for(int i= 0; i< distinctVals.size(); i++) {
            int count = 0;
            // loop original array, counting occurrences of distinct value.
            for (int v =0; v<array.length; v++) {
                if(array[v] == distinctVals.get(i)) {
                  count++;
                }
            }
            arrayIndex[i] = count;
        }
        int highOcc = 0;
        int highIdx = 0;
        // Loop occurrences count array and set the index value
        // of the distinct value that has the most occurrences.
        for(int i= 0; i < arrayIndex.length; i++) {
        	int occ = arrayIndex[i];
        	if (occ > highOcc) {
        		highOcc = occ;
        		highIdx = i;
        	}
        }
        value = distinctVals.get(highIdx);
        return value;
    }

	/*******************************************************************
	 * METHOD: getNextRowWrite
	 *
	 * A helper method calculating the next row to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon horizontal layer views.
	 ******************************************************************/
	private static int getNextRowWrite(ImportLayerData ilData, int rowStart) throws Exception {	
		int nextRowWrite = rowStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONHORIZ).contains(ilData.layer)) {
			if ((rowStart != 1) && (ilData.rowInterval != 1)) {
				nextRowWrite = (((rowStart/ilData.rowInterval)*ilData.rowInterval)+1);
			}
		} 
		return nextRowWrite;
	}

	/*******************************************************************
	 * METHOD: getNextColWrite
	 *
	 * A helper method calculating the next column to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon vertical layer views.
	 ******************************************************************/
	private static int getNextColWrite(ImportLayerData ilData, int colStart) throws Exception {	
		int nextColWrite = colStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONVERT).contains(ilData.layer)) {
			if ((colStart != 1) && (ilData.colInterval != 1)) {
				nextColWrite = (((colStart/ilData.colInterval)*ilData.colInterval)+1);
			}
		} 
		return nextColWrite;
	}

	/*====================================================================
	 * END: TILE WRITING METHODS
	 *==================================================================*/


	/*====================================================================
	 * BEGIN: OUTPUT FILE WRITING METHODS
	 *
	 * The methods that follow, from here to the end of the file, write
	 * the various output files generated by the HeatmapDataGenerator 
	 * process.  They include:
	 * 1. The mapData.JSON file containing supporting data for the map
	 * 2. The mapConfig.JSON file containing configurationd data for the map
	 *
	 * START: mapData.JSON file writing methods
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeMapDataFile
	 *
	 * This method is the main driver for the generation of the 
	 * mapData.JSON file.  It creates an output stream writer for the file
	 * using the output directory specified for the heatMap.  Then the 
	 * rowData and colData JSON subschemas are written to the file. The 
	 * rowData subschema contains row label data, row dendrogram data, and
	 * row classification (covariate) data.  The colData subschem contains
	 * similar data for the heatMap columns.
	 ******************************************************************/
   	private static void writeMapDataFile(ImportData iData, ImportLayerData summaryLayer) throws Exception {
		DataOutputStream writer = null;
		OutputStreamWriter fw = null;
		try {
			writer = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+MAP_DATA_FILE));
			fw = new OutputStreamWriter(writer, UTF8);
			//Write out row_data JSON section
	        fw.write(BRACE_OPEN+ROWDATA_LABEL+BRACE_OPEN);
	        writeLabels(fw, iData, true);
	        writeDataDendrogram(fw, iData, true);
	        writeDataClassifications(fw, iData, summaryLayer, true);
	        fw.write(BRACE_CLOSE+BRACE_CLOSE+COMMA);
			//Write out col_data JSON section
	        fw.write(COLDATA_LABEL+BRACE_OPEN);
	        writeLabels(fw, iData, false);
	        writeDataDendrogram(fw, iData, false);
	        writeDataClassifications(fw, iData, summaryLayer, false); 
	        fw.write(BRACE_CLOSE+BRACE_CLOSE+BRACE_CLOSE);
	    } catch (Exception ex) {
			System.out.println("Exception Writing mapData.JSON file: " + ex.toString());  
	        throw ex;
	    } finally {
			fw.close();
			writer.close();
	    }
	}
			
	/*******************************************************************
	 * METHOD: writeLabels
	 *
	 * This method writes out the colLabels and rowLabels JSON subschema
	 * data to the mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  The reOrgMatrix 2-D string array 
	 * stored on the ImportData object is traversed pulling either row or 
	 * column headers from the matrix in clustered order.
	 ******************************************************************/
	private static void writeLabels(OutputStreamWriter w, ImportData iData, boolean isRowFile) throws Exception {	
		// Build String constants
		// Loop thru import layers and write out structure data for each.
		if (isRowFile) {
			//Sometimes label hidden fields are loaded from a separate file into this hash.  Otherwise it will be empty.
			HashMap<String, String> extraLabelInfo = loadExtraLabel(iData.rowData.labelExtraFile);
		    w.write(LABEL_LABEL+BRACE_OPEN+LABEL_TYPE_LABEL+BRACKET_OPEN);
		    //Write data types - can be more than one.
		    for (int i = 0; i < iData.rowData.dataTypes.length; i++) { 
		    	w.write(QUOTE+iData.rowData.dataTypes[i]+QUOTE);
		    	if (i < iData.rowData.dataTypes.length-1) w.write(COMMA);
		    }
		    w.write(BRACKET_CLOSE+COMMA+LABELS_LABEL+BRACKET_OPEN);
	        for (int row = 1; row < iData.rowData.classArray.length; row++) {
	        	String initLabel = iData.rowData.classArray[row].equals(CUT_VALUE) ? "" : iData.rowData.classArray[row];
	        	String label = addExtra(initLabel, extraLabelInfo);
        	    w.write(QUOTE+label+QUOTE);
				if (row < (iData.rowData.classArray.length-1)) {
					w.write(COMMA);
				}
	        }
		} else {
			//Sometimes label hidden fields are loaded from a separate file into this hash.  Otherwise it will be empty.
			HashMap<String, String> extraLabelInfo = loadExtraLabel(iData.colData.labelExtraFile);
		    w.write(LABEL_LABEL+BRACE_OPEN+LABEL_TYPE_LABEL+BRACKET_OPEN);
		    //Write data types - can be more than one.
		    for (int i = 0; i < iData.colData.dataTypes.length; i++) { 
		    	w.write(QUOTE+iData.colData.dataTypes[i]+QUOTE);
		    	if (i < iData.colData.dataTypes.length-1) w.write(COMMA);
		    }
		    w.write(BRACKET_CLOSE+COMMA+LABELS_LABEL+BRACKET_OPEN);
	        for (int col = 1; col < iData.colData.classArray.length; col++) {
	        	String initLabel = iData.colData.classArray[col].equals(CUT_VALUE) ? "" : iData.colData.classArray[col];
	        	String label = addExtra(initLabel, extraLabelInfo);
        	    w.write(QUOTE+label+QUOTE);
				if (col < (iData.colData.classArray.length-1)) {
					w.write(COMMA);
				}
	        }
		}
		w.write(BRACKET_CLOSE+BRACE_CLOSE);
	}
	
	/*******************************************************************
	 * METHOD: loadExtraLabel
	 * 
	 * In some situations, the hidden label information (pipe delimited
	 * info on row/column labels that is not visible in the browser) is
	 * not included in the data matrix but is provided as a separate file.
	 * This method reads the info from the separate file into a HashMap
	 * so it can be used when writing labels.
	 * 
	 * Extra label file is tab delimited with first column being the row/column
	 * label from the matrix and the second column being the string to append
	 * to the label with the '|' character.
	 *******************************************************************/
	private static HashMap<String, String> loadExtraLabel(String extraLabelFile) throws Exception {
		HashMap<String, String> extraLabelInfo = new HashMap<String, String>();
		if (extraLabelFile != null ) {
			BufferedReader br = new BufferedReader(new FileReader(extraLabelFile));
			//For now assume extra label file has no header.
			String line = br.readLine();
			while (line != null) {
				String toks[] = line.split("\t");
				if (toks.length == 2)
					extraLabelInfo.put(toks[0].trim(), toks[1].trim());

				line = br.readLine();
			}
			br.close();

		}
		return extraLabelInfo;
	}
	
	/*******************************************************************
	 * METHOD: addExtra
	 * 
	 * Helper method to lookup and add extra hidden fields to labels.
	 ******************************************************************/
	private static String addExtra(String label, HashMap<String, String> extraLabelInfo) throws Exception {
		// To accommodate tree cuts in data with blank label
		if (label == null) {
			label = EMPTY;
		} 
		//Add extra label information for labels that apply
		int pipeIdx = label.indexOf(PIPE);
		String visibleLabel = pipeIdx > 0 ? label.substring(0, pipeIdx) : label;
		if (extraLabelInfo.containsKey(visibleLabel)) {
			label = (label + PIPE + extraLabelInfo.get(visibleLabel));
		}
		return label;
	}
	
	/*******************************************************************
	 * METHOD: writeDendrogram
	 *
	 * This method writes out the dendrogram JSON subschema data to the 
	 * mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  A check is performed for 
	 * row/col to determine if a dendrogram exists.  If one is found a 
	 * second method is called that writes out the dendrogram data for
	 * the row/col to mapData.
	 ******************************************************************/
	private static void writeDataDendrogram(OutputStreamWriter fw, ImportData iData, boolean isRowFile) throws Exception {
		if (isRowFile) {
			if (iData.rowData.dendroFile != null) {
				populateDendrogramData(iData.rowData.dendroValues, fw, iData);
				fw.write(BRACKET_CLOSE);
	        }
		} else {
	        if (iData.colData.dendroFile!= null) {
				populateDendrogramData(iData.colData.dendroValues, fw, iData);
				fw.write(BRACKET_CLOSE);
	        }
		}
	}
	
	/*******************************************************************
	 * METHOD: populateDendrogramData
	 *
	 * This method writes out the dendrogram JSON subschema data to the 
	 * mapData.JSON file. A given row/col dendrogram file is traversed
	 * and data is written out to an outputStreamWriter for the mapData
	 * JSON file.
	 ******************************************************************/
	private static void populateDendrogramData(List<String> dendroValues, OutputStreamWriter fw, ImportData iData) throws Exception {
        boolean firstTimeThrough = true;
        fw.write(COMMA+DENDROGRAM_LABEL+BRACKET_OPEN);
        for (int i=0; i<dendroValues.size();i++) {
            if (firstTimeThrough){
                firstTimeThrough = false;
            } else {
                fw.write(COMMA);
            }
            String dendroLineData = dendroValues.get(i);
            fw.write(QUOTE+dendroLineData+QUOTE);
        }
	}
	/*******************************************************************
	 * METHOD: writeClassifications
	 *
	 * This method writes out the classificaton (covariate) JSON subschema 
	 * data to the mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  A check is performed for 
	 * row/col to determine if a classification exists.  If one is found, the
	 * data is re-ordered into clustered order to match the re-ordered matrix
	 * data and then a second method is called that writes out the classification 
	 * data for the row/col to mapData.
	 ******************************************************************/
	private static void writeDataClassifications(OutputStreamWriter fw, ImportData iData, ImportLayerData ilData, boolean isRowFile) throws Exception {
		int rowInterval = (ilData!=null) ? ilData.rowInterval : 1;
		int colInterval = (ilData!=null) ? ilData.colInterval : 1;
        fw.write(COMMA+CLASSIFICATIONS_LABEL+BRACE_OPEN);
        if (isRowFile) {
			if (iData.rowData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.rowData.classFiles.size();i++) {
		        	InputClass currInput = iData.rowData.classFiles.get(i);
		        	populateClassifications(currInput, currInput.orderedClass, fw, rowInterval, isRowFile);
	        		fw.write(BRACE_CLOSE);
		        	if (i != iData.rowData.classFiles.size() - 1) {
		        		fw.write(COMMA);
		        	}
		        } 
			} 
        } else {
			if (iData.colData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.colData.classFiles.size();i++) {
		        	InputClass currInput = iData.colData.classFiles.get(i);
		        	populateClassifications(currInput, currInput.orderedClass, fw, colInterval, isRowFile);
	        		fw.write(BRACE_CLOSE);
		        	if (i != iData.colData.classFiles.size() - 1) {
		        		fw.write(COMMA);
		        	}
		        } 
			}
        }
	}
	
	/*******************************************************************
	 * METHOD: populateClassifications
	 *
	 * This method writes out the classification JSON subschema data to the 
	 * mapData.JSON file. The re-ordered classification data passed into
	 * this method is traversed and data is written out to an outputStreamWriter 
	 * for the mapData JSON file.  If more than summary level data exists
	 * for the heatMap, a second subschema (svalues) that is sampled at
	 * the summary level using the summary interval, is written to the
	 * JSON file in addition to the values subschema.
	 ******************************************************************/
	private static void populateClassifications(InputClass currFile, String classData[], OutputStreamWriter fw, int interval, boolean isRowFile) throws Exception {
        fw.write(QUOTE+currFile.name+QUOTE+COLON+LINE_FEED+BRACE_OPEN);
        fw.write(QUOTE+"values"+QUOTE+COLON+LINE_FEED+TAB+TAB+BRACKET_OPEN);
        boolean isDiscrete = currFile.map.type.equals(COLORTYPE_DISCRETE) ? true : false;
        // Write out a separate "values" node containing values for the classification file
        for (int row = 1; row < classData.length; row++) {
        	writeClassValue(classData[row], row, classData.length, fw, 1, isDiscrete);
        }
        // Write out a separate "svalues" node containing values for the classification file
        // this dataset will be sampled at the same level as the summary layer.
        if (interval > 1) {
        	int sValen = (classData.length-1)/interval;
        	float remn = ((float)classData.length-1)/interval%1;
        	if (remn > 0) {
        		sValen++;
        	}
    		String sValArr[] = new String[sValen+1];
    		int sValCtr = 0;
	        fw.write(COMMA+QUOTE+"svalues"+QUOTE+COLON+LINE_FEED+BRACKET_OPEN);
	        float aggrVal = 0;
	        int cutCtr = 0;
	        for (int row = 1; row < classData.length; row++) {
	        	int adjustedPos = row - 1;
	    		float remainder = ((float)adjustedPos/interval)%1;
	    		String dataItem = classData[row] == null ? "NA" : classData[row];
	    		if (currFile.map.type.equals(COLORTYPE_CONTINUOUS)) {
	    			if (dataItem.equals(CUT_VALUE) || NA_VALUES.contains(dataItem)) {
	    				cutCtr++;
	    			} else {
	    				aggrVal = aggrVal+Float.parseFloat(dataItem);
	    			}
	    		}
	    		if (remainder == 0) {
		    		if (currFile.map.type.equals(COLORTYPE_CONTINUOUS)) {
		    			if ((aggrVal == 0) && (dataItem.equals(CUT_VALUE) || NA_VALUES.contains(dataItem))) {
			    			writeClassValue(dataItem, row, classData.length, fw, interval, isDiscrete);
		    			} else {
			    			String avgVal = Float.toString(aggrVal/(interval-cutCtr));
			    			writeClassValue(avgVal, row, classData.length, fw, interval, isDiscrete);
		    			}
		    		} else {
		    			writeClassValue(dataItem, row, classData.length, fw, interval, isDiscrete);
		    		}
		        	sValCtr++;
		        	sValArr[sValCtr] = classData[row];
		        	aggrVal = 0;
		        	cutCtr = 0;
	    		} 
	        }
        } 
    	fw.write(LINE_FEED);
	}
	
	/*******************************************************************
	 * METHOD: writeClassValue
	 *
	 * This is a utility method used by populateClassifications to
	 * write out string and numeric values to the classifications subschema
	 * in the mapData.JSON file. 
	 ******************************************************************/
	private static void writeClassValue(String val, int row, int len, OutputStreamWriter fw, int interval, boolean discrete) throws Exception {
		fw.write(QUOTE+val+QUOTE);
    	if (row+interval < len) {
    		fw.write(COMMA);
    	} else {
    		fw.write(BRACKET_CLOSE);
    	}
	}
	
	/*====================================================================
	 * END: mapData.JSON file writing methods
	 * 
	 * START: mapConfig.JSON file writing methods
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeMapConfigFile
	 *
	 * This method is the main driver for the generation of the 
	 * mapConfig.JSON file.  It creates an output stream writer for the file
	 * using the output directory specified for the heatMap.  Then the 
	 * data_configuration, row_configuration, and col_configuration JSON 
	 * subschemas are written to the file. The data_configuration subschema
	 * contains the following JSON subschemas:
	 * 1. map_information: Containing global configuration for the map
	 * 2. levels: Containing data level (eg thumbnail, summary, etc) 
	 *            configuration for the map.
	 * 3. data_layer: Containing data layer (flick) configuration for the map.

	 * The row_configuration and col_configuration subschemas contain the 
	 * following JSON subschemas for row/col configuration:	   
	 * 1. organization: Containing ordering (clustering) configuration for map.
	 * 2. dendrogram: Containing dendrogram configuration for the map. 
	 * 3. classifications: Containing classification (covariate) configuration 
	 *                     for the map. 
	 ******************************************************************/
   	private static void writeMapConfigFile(ImportData iData) throws Exception {
		DataOutputStream writer = null;
		OutputStreamWriter fw = null;
		try {
			writer = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+MAP_CONFIG_FILE));
			fw = new OutputStreamWriter(writer, UTF8);
			//Write out data configuration JSON section
	        fw.write(BRACE_OPEN+DATA_CONFIG_LABEL+BRACE_OPEN);
	        writeMapInformation(fw, iData);
	        writeMapStructure(fw, iData);
	        writeDataLayers(fw, iData);
	        fw.write(BRACE_CLOSE);
	        fw.write(BRACE_CLOSE+COMMA);
			//Write out column configuration JSON section
	        fw.write(ROW_CONFIG_LABEL+BRACE_OPEN);
	        writeTopItems(fw, iData, true);
	        writeOrganization(fw, iData, true);
	        writeLabelConfig(fw, iData, true);
	        writeConfigDendrogram(fw, iData, true);
	        writeConfigClassifications(fw, iData, true);
	        fw.write(BRACE_CLOSE+COMMA);
			//Write out row configuration JSON section
	        fw.write(COL_CONFIG_LABEL+BRACE_OPEN);
	        writeTopItems(fw, iData, false);
	        writeOrganization(fw, iData, false);
	        writeLabelConfig(fw, iData, false);
	        writeConfigDendrogram(fw, iData, false);
	        writeConfigClassifications(fw, iData, false);
	        fw.write(BRACE_CLOSE+BRACE_CLOSE);
	    } catch (Exception ex) {
			System.out.println("Exception Writing mapConfig.JSON file: " + ex.toString());  
	        throw ex;
	    } finally {
	    	fw.close();
	    	writer.close();
	    }
	}
				           
	/*******************************************************************
	 * METHOD: writeMapInformation
	 *
	 * This method writes out the map_information JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file. Configuration
	 * data for the heatmap name, description, and any attributes provided
	 * to the builder are written out.
	 ******************************************************************/
	private static void writeMapInformation(OutputStreamWriter fw, ImportData iData)  throws Exception {
        fw.write(MAP_INFO_LABEL+BRACE_OPEN);
        fw.write(NAME_LABEL+QUOTE+iData.chmName+QUOTE+COMMA);
        fw.write(DESC_LABEL+QUOTE+iData.chmDescription+QUOTE+COMMA);
        fw.write(BUILDER_VER_LABEL+QUOTE+iData.builderVersion+QUOTE+COMMA);
        fw.write(READ_ONLY_LABEL+QUOTE+iData.readOnly+QUOTE+COMMA);
        fw.write(VERSION_LABEL+QUOTE+CURRENT_GENERATOR_VERSION+QUOTE+COMMA);
        fw.write(LABEL_LENGTH_LABEL+LABEL_LENGTH_DEFAULT+COMMA);
        fw.write(LABEL_TRUNCATION_LABEL+LABEL_TRUNCATE_DEFAULT+COMMA);
        fw.write(SUMMARY_WIDTH_LABEL+QUOTE+iData.summaryWidth+QUOTE+COMMA);
        fw.write(SUMMARY_HEIGHT_LABEL+QUOTE+iData.summaryHeight+QUOTE+COMMA);
        fw.write(DETAIL_WIDTH_LABEL+QUOTE+iData.detailWidth+QUOTE+COMMA);
        fw.write(DETAIL_HEIGHT_LABEL+QUOTE+iData.detailHeight+QUOTE+COMMA);
        int cutRows = iData.rowData.cutLocations.length*iData.rowData.cutWidth;
        int cutCols = iData.colData.cutLocations.length*iData.colData.cutWidth;
        fw.write(MAP_CUT_ROWS_LABEL+QUOTE+cutRows+QUOTE+COMMA);
        fw.write(MAP_CUT_COLS_LABEL+QUOTE+cutCols+QUOTE+COMMA);
        fw.write(ATTRS_LABEL+BRACE_OPEN);
        for (int i=0;i<iData.chmAttributes.size();i++) {
        	AttributeData ad = iData.chmAttributes.get(i);
	        fw.write(QUOTE+ad.attributeName+QUOTE+COLON+QUOTE+ad.attributeValue+QUOTE);
        	if (i != (iData.chmAttributes.size() - 1)) {
        		fw.write(COMMA);
        	}
        } 
        fw.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeMapStructure
	 *
	 * This method writes out the levels JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file.	 This 
	 * subschema contains the tile structure for the heatmap. A thumb will 
	 * always be written.  The levels  below will be written to the file if 
	 * they are generated.
	 ******************************************************************/
	private static void writeMapStructure(OutputStreamWriter w, ImportData iData)  throws Exception {	
		InputFile iFile = iData.matrixFiles.get(0);
		w.write(LEVELS_LABEL+BRACE_OPEN);
		// Loop thru import layers and write out structure data for each.
		for (int i=0; i < iFile.importLayers.size(); i++) {
			ImportLayerData ilData = iFile.importLayers.get(i);
			// Write out the Thumbnail file structure data.
			w.write(QUOTE+ilData.layer+QUOTE+COLON);
			w.write(BRACE_OPEN);
			w.write(TILEROWS_LABEL+ilData.rowTiles);
			w.write(COMMA+TILECOLS_LABEL+ilData.colTiles);
			w.write(COMMA+TILEROWSPER_LABEL+ilData.rowsPerTile);
			w.write(COMMA+TILECOLSPER_LABEL+ilData.colsPerTile);
			w.write(COMMA+TOTALROWS_LABEL+ilData.totalLevelRows);
			w.write(COMMA+TOTALCOLS_LABEL+ilData.totalLevelCols);
			w.write(COMMA+ROW_SUMMARY_RATIO_LABEL+ilData.rowInterval);
			w.write(COMMA+COL_SUMMARY_RATIO_LABEL+ilData.colInterval);
			w.write(BRACE_CLOSE);
			if (i < (iFile.importLayers.size() - 1)) {
				w.write(COMMA);
			}
		}
		w.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeDataLayers
	 *
	 * This method writes out the data_layer JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file.	 This 
	 * subschema contains a configuration for each matrix file (primary and
	 * flicks) in the heatmap. This method starts writing the subschema, 
	 * placing the data layer id and name in the subschema, and then calls
	 * a method to write the colormap configuration for the data layer into
	 * the mapConfig.JSON file.
	 ******************************************************************/
	private static void writeDataLayers(OutputStreamWriter fw, ImportData iData)  throws Exception {	
        fw.write(DATA_LAYER_LABEL+BRACE_OPEN);
		// Build String constants
		for (int i=0; i < iData.matrixFiles.size(); i++) {
			InputFile iFl = iData.matrixFiles.get(i);
			fw.write(QUOTE+iFl.id+QUOTE+COLON+BRACE_OPEN);
			fw.write(NAME_LABEL+QUOTE+iFl.name+QUOTE+COMMA);
			fw.write(GRID_SHOW_LABEL+QUOTE+iFl.gridShow+QUOTE+COMMA);
			fw.write(GRID_COLOR_LABEL+QUOTE+iFl.gridColor+QUOTE+COMMA);
			fw.write(CUTS_COLOR_LABEL+QUOTE+iFl.cutsColor+QUOTE+COMMA);
			fw.write(SELECTION_COLOR_LABEL+QUOTE+iFl.selectionColor+QUOTE+COMMA);
			writeColorMap(fw, iData, i, DATA_LAYER_LABEL);
			fw.write(BRACE_CLOSE);
			
			if (i < iData.matrixFiles.size() - 1) {
				fw.write(COMMA);
			}
		}
		fw.write(BRACE_CLOSE);
	}	

	/*******************************************************************
	 * METHOD: writeColorMap
	 *
	 * This method writes out the colorMap JSON subschema of the 
	 * data_layers AND classifications subschemas of the mapConfig.JSON file.	 
	 ******************************************************************/
	private static void writeColorMap(OutputStreamWriter fw, ImportData iData, int filePos, String mapType)  throws Exception {
		ColorMap cMap = null;
		if (DATA_LAYER_LABEL.equals(mapType)) {
	        InputFile iFile = iData.matrixFiles.get(filePos);
	        cMap = iFile.getMap();
		} else {
	        InputClass iFile;
			if (ROW_CONFIG_LABEL.equals(mapType)) {
		        iFile = iData.rowData.classFiles.get(filePos);
			} else {
				iFile = iData.colData.classFiles.get(filePos);
			} 
	        cMap = iFile.getMap();
	    }
        fw.write(cMap.asJSON());
	}	
	
	/*******************************************************************
	 * METHOD: writeOrganization
	 *
	 * This method writes out the organization JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is used to drive the This subschema contains the row/col organization configuration 
	 * for the heatmap.
	 ******************************************************************/
	private static void writeOrganization(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		// Build String constants
		fw.write(ORGANIZATION_LABEL+BRACE_OPEN);
		// Loop thru import layers and write out structure data for each.
		if (isRowFile) {
		    String rowOrderMethod = iData.rowData.orderMethod;
		    fw.write(ORDER_METHOD_LABEL+QUOTE+rowOrderMethod+QUOTE+COMMA);
		    if (ORDER_HIERARCHICAL.equals(rowOrderMethod)) {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+iData.rowData.agglomerationMethod+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+iData.rowData.distanceMetric+QUOTE);
		    } else {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+NONE+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+NONE+QUOTE);
		    }
		} else {
		    String cowOrderMethod = iData.colData.orderMethod;
		    fw.write(ORDER_METHOD_LABEL+QUOTE+cowOrderMethod+QUOTE+COMMA);
		    if (ORDER_HIERARCHICAL.equals(cowOrderMethod)) {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+iData.colData.agglomerationMethod+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+iData.colData.distanceMetric+QUOTE);
		    } else {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+NONE+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+NONE+QUOTE);
		    }
		}
		fw.write(BRACE_CLOSE+COMMA);
	}	
	
	/*******************************************************************
	 * METHOD: writeLabelConfig
	 *
	 * This method writes out label configuration data to the mapConfig
	 * JSON file. Configuration data written includes the maximum display
	 * length for a label and the method for abbreviating that label.
	 ******************************************************************/
	private static void writeLabelConfig(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		RowColData data = iData.rowData;
		if (!isRowFile) {
			data = iData.colData;
		}
	    fw.write(LABEL_LENGTH_LABEL+QUOTE+data.labelMaxLength+QUOTE+COMMA);
	    fw.write(LABEL_ABBREV_METHOD_LABEL+QUOTE+data.labelAbbrevMethod+QUOTE+COMMA);
	}	

	/*******************************************************************
	 * METHOD: writeTopItems
	 *
	 * This method writes out top row/column label items to the mapConfig
	 * JSON file.  These items are defined by the incoming heatmapConfig
	 * JSON file and are used to display specific "top" labels on the
	 * Summary heatmap in the viewer application.
	 ******************************************************************/
	private static void writeTopItems(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		String[] topItems = iData.rowData.topItems;
		if (!isRowFile) {
			topItems = iData.colData.topItems;
		}
	    fw.write(TOP_ITEMS_LABEL+BRACKET_OPEN);
		if (topItems != null) {
			for (int i=0;i<topItems.length;i++) {
				fw.write(QUOTE+topItems[i]+QUOTE);
				if (i < topItems.length-1) {
					fw.write(COMMA);
				}
			}
		}
		fw.write(BRACKET_CLOSE+COMMA);
	}	
	
	/*******************************************************************
	 * METHOD: writeConfigDendrogram
	 *
	 * This method writes out the dendrogram JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is passed in to differentiate between the two during 
	 * processing. This subschema contains the dendrogram configuration 
	 * for the heatmap.
	 ******************************************************************/
	private static void writeConfigDendrogram(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {
        fw.write(DENDROGRAM_LABEL+BRACE_OPEN);
		if (isRowFile) {
	        if (iData.rowData != null) {
		        fw.write(SHOW_LABEL+QUOTE+iData.rowData.showDendro+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+iData.rowData.heightDendro+QUOTE); 
	        } else {
		        fw.write(SHOW_LABEL+QUOTE+"NA"+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+"10"+QUOTE); 
	        }
		} else {
	        if (iData.colData.dendroFile!= null) {
		        fw.write(SHOW_LABEL+QUOTE+iData.colData.showDendro+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+iData.colData.heightDendro+QUOTE); 
	        } else {
		        fw.write(SHOW_LABEL+QUOTE+"NA"+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+"10"+QUOTE); 
	        }
		}
        fw.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeConfigClassifications
	 *
	 * This method writes out the classification (covariate) JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is passed in to differentiate between the two during 
	 * processing. This subschema contains the classification configuration
	 * variable and colormap for the heatmap.
	 ******************************************************************/
	private static void writeConfigClassifications(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {
        fw.write(CLASSIFICATIONS_LABEL+BRACE_OPEN);
		String classOrder = BRACKET_OPEN;
		if (isRowFile) {
			if (iData.rowData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.rowData.classFiles.size();i++) {
		        	InputClass currInput = iData.rowData.classFiles.get(i);
		        	classOrder += QUOTE+currInput.name+QUOTE;
					fw.write(QUOTE+currInput.name+QUOTE+COLON+BRACE_OPEN);
					fw.write(HEIGHT_LABEL+QUOTE+currInput.height+QUOTE+COMMA);
					fw.write(SHOW_LABEL+QUOTE+currInput.show+QUOTE+COMMA);
			        fw.write(BAR_TYPE_LABEL+QUOTE+currInput.barType+QUOTE+COMMA);
			        if (currInput.dataType != null) {
				        fw.write(DATA_TYPE_LABEL+QUOTE+currInput.dataType+QUOTE+COMMA);
			        }
			        fw.write(FG_COLOR_LABEL+QUOTE+currInput.fgColor+QUOTE+COMMA);
			        fw.write(BG_COLOR_LABEL+QUOTE+currInput.bgColor+QUOTE+COMMA);
			        fw.write(LOW_BOUND_LABEL+QUOTE+currInput.lowBound+QUOTE+COMMA);
			        fw.write(HIGH_BOUND_LABEL+QUOTE+currInput.highBound+QUOTE+COMMA);
					writeColorMap(fw, iData, i,ROW_CONFIG_LABEL);
					if (i < iData.rowData.classFiles.size() - 1) {
			        	classOrder += COMMA;
						fw.write(BRACE_CLOSE+COMMA);
					} else {
						fw.write(BRACE_CLOSE);
					}
		        }
			}
		} else {
			if (iData.colData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.colData.classFiles.size();i++) {
		        	InputClass currInput = iData.colData.classFiles.get(i);
		        	classOrder += QUOTE+currInput.name+QUOTE;
					fw.write(QUOTE+currInput.name+QUOTE+COLON+BRACE_OPEN);
					fw.write(HEIGHT_LABEL+QUOTE+currInput.height+QUOTE+COMMA);
					fw.write(SHOW_LABEL+QUOTE+currInput.show+QUOTE+COMMA);
			        fw.write(BAR_TYPE_LABEL+QUOTE+currInput.barType+QUOTE+COMMA);
			        if (currInput.dataType != null) {
				        fw.write(DATA_TYPE_LABEL+QUOTE+currInput.dataType+QUOTE+COMMA);
			        }
			        fw.write(FG_COLOR_LABEL+QUOTE+currInput.fgColor+QUOTE+COMMA);
			        fw.write(BG_COLOR_LABEL+QUOTE+currInput.bgColor+QUOTE+COMMA);
			        fw.write(LOW_BOUND_LABEL+QUOTE+currInput.lowBound+QUOTE+COMMA);
			        fw.write(HIGH_BOUND_LABEL+QUOTE+currInput.highBound+QUOTE+COMMA);
					writeColorMap(fw, iData, i,COL_CONFIG_LABEL);
					if (i < iData.colData.classFiles.size() - 1) {
			        	classOrder += COMMA;
						fw.write(BRACE_CLOSE+COMMA);
					} else {
						fw.write(BRACE_CLOSE);
					}
		        }
			}
		}
        fw.write(BRACE_CLOSE+COMMA);
        classOrder += BRACKET_CLOSE;
        fw.write(CLASSIFICATIONS_ORDER_LABEL+classOrder);
	}
	
	/*====================================================================
	 * END: mapConfig.JSON file writing methods
	 * 
	 * END OUTPUT FILE WRITING METHODS
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeClusteredDebugFile
	 *
	 * This method is for debugging.  It writes out the clustered
	 * data matrix to a file called clustered.txt in the matrix data dir.
	 ******************************************************************/
	private static void writeClusteredDebugFile(ImportData iData, InputFile iFile, float[][] clusteredMatrix, int fileNo) {	
		DataOutputStream writeRow = null;
		OutputStreamWriter w = null;
		try {
			String dlDir = "dl"+fileNo;
			writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+"clustered.txt"));
			w = new OutputStreamWriter(writeRow, UTF8);
	        for (int row = 0; row < clusteredMatrix.length; row++) {
		        for (int col = 0; col < clusteredMatrix[0].length; col++) {
		        	float val = clusteredMatrix[row][col];
		        	w.write(String.valueOf(val));
					if (col < (clusteredMatrix[0].length-1)) {
						w.write(TAB);
					} else {
						w.write(LINE_FEED);
					}
		        }
	        }
			w.close();
			writeRow.close();
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.writeClusteredDebugFile: " + ex.toString());  
	        ex.printStackTrace();
	    } finally {
	    	try {
	    		w.close();
	    		writeRow.close();
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*====================================================================
	 * BEGIN IMAGE CREATION METHODS USED IN GENERATING THUMBNAIL IMAGES
	 * AND THE HEAT MAP PDF.
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: createSummaryImg
	 *
	 * This method creates the preview image using the summary level info
	 * and the color map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static void createSummaryImg(ColorMap cMap, ImportData iData, Float sumMatrix[][]){
		try {
			int width = sumMatrix[0].length;
	        int height = sumMatrix.length;
	        int numBreaks = cMap.breaks.size();
	        Color lowExCol = cMap.colors.get(0);
	        Color hiExCol = cMap.colors.get(numBreaks-1);
	        Color missingCol = cMap.missingColor;
	        float lowEx = Float.parseFloat(cMap.breaks.get(0));
	        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
	        
	        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	        
	        // BUILD HEAT MAP IMAGE
	        // go through each value in the SUMMARY matrix and determine the color for the pixel
	        for (int y = 0; y < height; y++) {
	            for (int x = 0; x < width; x++) {
	                float val = sumMatrix[y][x];
	                int rgb;
	                if (val == MIN_VALUES) {
	                	rgb = RGB_WHITE;
	                } else if (val == MAX_VALUES) {
	                	rgb = missingCol.getRGB();
	                } else {
		                if (val > hiEx){
		                    rgb = hiExCol.getRGB();
		                } else if (val < lowEx){
		                    rgb = lowExCol.getRGB();
		                } else {
		                    int i = 0;
		                    // find the breakpoints that this value is between
		                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
		                    	i++;
		                    };
		                    Color lowCol = cMap.colors.get(i-1);
		                    Color hiCol = cMap.colors.get(i);
		                    float low = Float.parseFloat(cMap.breaks.get(i-1));
		                    float hi = Float.parseFloat(cMap.breaks.get(i));
		                    float ratio = (hi-val)/(hi-low);
		                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
		                    rgb = blend.getRGB();
		                }
	                }
	                image.setRGB(x, y, rgb);
	            }
	        }
			iData.matrixImages.add(image);
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createSummaryImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: createDetailImg
	 *
	 * This method creates the preview image using the summary level info
	 * and the color map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static void createDetailImg(ColorMap cMap, ImportData iData, Float detMatrix[][]){
		try {
			int width = detMatrix[0].length;
	        int height = detMatrix.length;
	        int numBreaks = cMap.breaks.size();
	        Color lowExCol = cMap.colors.get(0);
	        Color hiExCol = cMap.colors.get(numBreaks-1);
	        Color missingCol = cMap.missingColor;
	        float lowEx = Float.parseFloat(cMap.breaks.get(0));
	        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
	        
	        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	        
	        // BUILD HEAT MAP IMAGE
	        // go through each value in the Detail matrix and determine the color for the pixel
	        for (int y = 0; y < height; y++) {
	            for (int x = 0; x < width; x++) {
	                float val = detMatrix[y][x];
	                int rgb;
	                if (val == MIN_VALUES) {
	                	rgb = RGB_WHITE;
	                } else if (val == MAX_VALUES) {
	                	rgb = missingCol.getRGB();
	                } else {
		                if (val > hiEx){
		                    rgb = hiExCol.getRGB();
		                } else if (val < lowEx){
		                    rgb = lowExCol.getRGB();
		                } else {
		                    int i = 0;
		                    // find the breakpoints that this value is between
		                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
		                    	i++;
		                    };
		                    Color lowCol = cMap.colors.get(i-1);
		                    Color hiCol = cMap.colors.get(i);
		                    float low = Float.parseFloat(cMap.breaks.get(i-1));
		                    float hi = Float.parseFloat(cMap.breaks.get(i));
		                    float ratio = (hi-val)/(hi-low);
		                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
		                    rgb = blend.getRGB();
		                }
	                }
	                image.setRGB(x, y, rgb);
	            }
	        }
			iData.matrixImages.add(image);
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createDetailImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: createColDendroImg
	 *
	 * This method creates a PNG image of the column dendrogram for a 
	 * given heat map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static BufferedImage createColDendroImg(ImportData iData, Float sizeTo) {
		BufferedImage image = null;
		try {
			int dendroWidth = iData.colData.dendroMatrix[0].length;
			int dendroHeight = iData.colData.dendroMatrix.length;
			//This factor reduces the dendro size to the number of inches on a BufferedImage divides by 5.5 
			//to determine how many values to factor to make the dendro approximately 5.5 inches wide
			Float lowSample = new Float(new Float(dendroWidth)/120)/sizeTo;
			boolean lowSampInd = false;
			if (lowSample < .5) {
				lowSampInd = true;
			}
			Float sampleFactor = new Float(Math.round((dendroWidth/120)/sizeTo));
			sampleFactor = sampleFactor > 0 ? sampleFactor : 1;
			if (lowSampInd) {
				sampleFactor = new Float(Math.round(1/lowSample));
				//Set sampling factor to an even number
				if ((sampleFactor%2)!=0) sampleFactor--;
				//Factor up the width of the image
				dendroWidth *= sampleFactor;
			} else {
				//Factor down the width of the image
				dendroWidth /= sampleFactor;
				
			}
	        image = new BufferedImage(dendroWidth, dendroHeight, BufferedImage.TYPE_INT_RGB);
	        //Build all white image to draw lines on
	        fillDendroImage(image, dendroHeight, dendroWidth, RGB_WHITE);
           	//Draw lines on the image
	        if (lowSampInd) {
	        	drawDendroImageLinesUpScale(image, iData.colData.dendroMatrix, dendroHeight, sampleFactor, COL);
	        } else {
	        	drawDendroImageLines(image, iData.colData.dendroMatrix, dendroHeight, sampleFactor, COL);
	        }
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createColDendroImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
		return image;
	}
	
	/*******************************************************************
	 * METHOD: createRowDendroImg
	 *
	 * This method creates a PNG image of the row dendrogram for a 
	 * given heat map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static BufferedImage createRowDendroImg(ImportData iData, Float sizeTo){
		BufferedImage image = null;
		try {
			int dendroWidth = iData.rowData.dendroMatrix[0].length;
			int dendroHeight = iData.rowData.dendroMatrix.length;
			//This factor reduces the dendro size to the number of inches on a BufferedImage divides by 5.5 
			//to determine how many values to factor to make the dendro approximately 5.5 inches tall
			Float lowSample = new Float(new Float(dendroWidth)/120)/new Float(sizeTo);
			boolean lowSampInd = false;
			if (lowSample < .5) {
				lowSampInd = true;
			}
			Float sampleFactor = new Float(Math.round((dendroWidth/120)/sizeTo)); 
			sampleFactor = sampleFactor > 0 ? sampleFactor : 1;
			if (lowSampInd) {
				sampleFactor = new Float(Math.round(1/lowSample));
				//Set sampling factor to an even number
				if ((sampleFactor%2)!=0) sampleFactor--;
				//Factor up the width of the image
				dendroWidth *= sampleFactor;
			} else {
				//Factor down the width of the image
				dendroWidth /= sampleFactor;
			}
	        image = new BufferedImage(dendroHeight, dendroWidth, BufferedImage.TYPE_INT_RGB);
	        //Build all white image to draw lines on
	        fillDendroImage(image, dendroWidth, dendroHeight, RGB_WHITE);
           	//Draw lines on the image
	        if (lowSampInd) {
	        	drawDendroImageLinesUpScale(image, iData.rowData.dendroMatrix, dendroHeight, sampleFactor, ROW);
	        } else {
	        	drawDendroImageLines(image, iData.rowData.dendroMatrix, dendroHeight, sampleFactor, ROW);
	        }
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createRowDendroImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
		return image;
	}	
	
	
	/*******************************************************************
	 * METHOD: fillDendroImage
	 *
	 * This method fills a prospective dendrogram BuffereImage with white
	 * space and is configurable for drawing on both Row and Column images.
	 ******************************************************************/
	public static void fillDendroImage(BufferedImage image, int dendroHeight, int dendroWidth, int fillColor)  {
		try {
		    //Build all white image to draw lines on
			for (int i = 0; i < dendroHeight; i++) {
				for (int j=0; j < dendroWidth; j++) {
		                image.setRGB(j, dendroHeight-(i+1), fillColor);
		 		}
			}
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.fillDendroImage: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}

	/*******************************************************************
	 * METHOD: drawDendroImageLines
	 *
	 * This method draws dendrogram lines on a BufferedImage and is 
	 * configurable for drawing both Row and Column lines.  It is utilized
	 * when the dendro image being created is smaller than the dendro matrix.
	 * Thus, the image is down-scaled.
	 ******************************************************************/
	private static void drawDendroImageLines(BufferedImage image, int[][] dendroMatrix, int dendroHeight, Float sampleFactor, String type) {
		try {
	       	//Draw lines on the image
	       	for (int i = 0; i < dendroHeight; i++) {
	    		int[] dendroRow = dendroMatrix[i];
	    		int sample = 0;
	    		int sampleSum = 0;
	    		int samplePos = 0;
	    		int jPos = 0;
	    		for (int j=0; j < dendroRow.length; j++) {
	    			if (sample < sampleFactor) {
	    				sampleSum += dendroRow[samplePos];
	        			samplePos++;
	        			sample++;
	    			} 
	    			if (sample == sampleFactor) {
	    				if (sampleSum > 0) {
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1)); //Draw
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos); //Draw
	    					}
	    				}
	    				sample = 0;
	    				sampleSum = 0;
	    				jPos++;
	    			}
	    		}
	    	} 
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.drawDendroImageLines: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: drawDendroImageLinesUpScale
	 *
	 * This method draws dendrogram lines on a BufferedImage and is 
	 * configurable for drawing both Row and Column lines.  It is utilized
	 * when the dendro image being created is larger than the dendro matrix.
	 * Thus, the image is up-scaled.
	 ******************************************************************/
	private static void drawDendroImageLinesUpScale(BufferedImage image, int[][] dendroMatrix, int dendroHeight, Float sampleFactor, String type) {
		try {
	       	//Draw lines on the image
			boolean lastWasSelected = false;
			 for (int i = 0; i < dendroHeight; i++) {
	    		int[] dendroRow = dendroMatrix[i];
	    		int jPos = 0;
	    		for (int j=0; j < dendroRow.length; j++) {
	    			int sampleVal = dendroRow[j];
	    			if (sampleVal == 1) {
	    				if (lastWasSelected) {
	    					//back up 1/2 a position and draw for 1 full position
	    					jPos -= sampleFactor/2;
	    					for (int k = 0; k < sampleFactor; k++) {
	        					if (type.equals(COL)) {
	        						setDendroImageValue(image, jPos, dendroHeight-(i+1));
	        					} else {
	        						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	        					}
	    						jPos++;
	    					}
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1));
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	    					}
	    					jPos += sampleFactor/2;
	    				} else {
	    					//draw one dot in the middle of one full position
		    				jPos += sampleFactor/2;
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1)); //Draw
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	    					}
		    				jPos += sampleFactor/2;
	    				}
	    				lastWasSelected = true;
	    			} else {
	    				//skip one full position
	    				lastWasSelected = false;
	    				jPos += sampleFactor;
	    			}
	    		}
	   		} 
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.drawDendroImageLinesUpScale: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: setDendroImageValue
	 *
	 * This method sets a black pixel on the submitted x/y coordinates
	 * in a BufferedImage containing a row/col dendrogram.
	 ******************************************************************/
	private static void setDendroImageValue(BufferedImage image, int x, int y) {
		try {
			image.setRGB(x, y, RGB_BLACK);	
		} catch (Exception e) {
			// Do nothing - for logging: System.out.println("setImageValue exception x: " + x + " y: " + y);
		}
	}
	
	/*******************************************************************
	 * METHOD: setTNDendroImageValue
	 *
	 * This method sets a black pixel on the submitted x/y coordinates
	 * in a BufferedImage containing a row/col dendrogram. This is an advanced
	 * version of the function that handles widths and line end conditions for
	 * special processing in the thumbnail image.
	 ******************************************************************/
	private static void setTNDendroImageValue(BufferedImage image, int x, int y, boolean columnDendro, int width, LineSegment seg) {
		try {
			if (columnDendro) {
				int start = x;
				int stop = x + 1;
				if (width > 1) {
					if (seg == LineSegment.MIDDLE) {
						start -= width/2;
						stop += width/2;
					} else if (seg == LineSegment.LEFT_END) {
						stop += width/2;
					} else if (seg == LineSegment.RIGHT_END) {
						start -= width/2;
					}
				}
				for (int xPos = start; xPos < stop; xPos++){
					image.setRGB(xPos, y, RGB_BLACK);
				}	
			} else {
				int start = y;
				int stop = y + 1;
				if (width > 1) {
					if (seg == LineSegment.MIDDLE) {
						start -= width/2;
						stop += width/2;
					} else if (seg == LineSegment.LEFT_END) {
						start -= width/2;
					} else if (seg == LineSegment.RIGHT_END) {
						stop += width/2;
					}
				}
				for (int yPos = start; yPos < stop; yPos++){
					image.setRGB(x, yPos, RGB_BLACK);
				}	
			}
		} catch (Exception e) {
			// Do nothing - for logging: System.out.println("setImageValue exception x: " + x + " y: " + y);
		}
	}

	/*==========================
	 * THUMBNAIL SPECIFIC LOGIC
	 *=========================*/

	/*******************************************************************
	 * METHOD: buildTnThumbnail
	 *
	 * This method constructs the completed thumbnail PNG from buffered
	 * images generated for the row/col dendros and the heat map.
	 ******************************************************************/
	 public static void buildTnThumbnail(ImportData iData) {
	        //do some calculate first
	        int offset  = 1;
	        int finalDendH = TN_HEIGHT;
	        Graphics g = null;
	        try {
				//BufferedImage rDScale = null;
				BufferedImage rDendImg = null;
				int rDendHgt = 0;
				if (iData.rowData.dendroMatrix != null) {
			        // Build scaled row dendro image for thumbnail
					rDendImg = createTnRowDendroImg(iData, TN_WIDTH, TN_HEIGHT);
					rDendHgt = rDendImg.getHeight();
				}
				//BufferedImage cDScale = null;
				BufferedImage cDendImg = null;
				int cDendWid = 0;
				if (iData.colData.dendroMatrix != null) {
			        // Build scaled column dendro image for thumbnail
					cDendImg = createTnColDendroImg(iData, TN_WIDTH, TN_HEIGHT);
					cDendWid = cDendImg.getWidth();
				}
	
				//Calculate total image height/width for thumbnail
				int imgWid = cDendWid > 0 ? cDendWid : TN_WIDTH+TN_HEIGHT;
				int imgHgt = rDendHgt > 0 ? rDendHgt : TN_WIDTH+TN_HEIGHT;
				int imgWDiff = 5;
				int imgHDiff = 5;
				
		        //Build scaled heat map image for thumbnail
		        BufferedImage hmImg = iData.tnImage;
		        BufferedImage hmScale = new BufferedImage(imgWid, imgHgt, BufferedImage.TYPE_INT_RGB);
				g = hmScale.createGraphics();
				g.drawImage(hmImg, 0, 0, imgWid, imgHgt, null);
				
				g.dispose();
		        
		        // Create a new buffer for completed thumbnail image
		        BufferedImage newImage = new BufferedImage(TN_THUMB_WIDTH,TN_THUMB_WIDTH, BufferedImage.TYPE_INT_ARGB);
		        
		        Graphics2D g2 = newImage.createGraphics();
		        Color oldColor = g2.getColor();
		        
		        // Fill background of thumbnail with white
		        g2.setPaint(Color.WHITE);
		        g2.fillRect(0, 0, TN_THUMB_WIDTH, TN_THUMB_WIDTH);
		        
		        // Draw thumbnail image from heat map and dendros
		        g2.setColor(oldColor);
		        g2.drawImage(rDendImg, null, imgWDiff, imgHDiff+finalDendH+offset);
		        g2.drawImage(cDendImg, null, imgWDiff+finalDendH+offset, imgHDiff);
		        g2.drawImage(hmScale, null, imgWDiff+finalDendH+offset, imgHDiff+finalDendH+offset);
		        g2.dispose();
		        File outputFile = new File(iData.outputDir+File.separator + iData.chmName + "_tn.png"); 
		        ImageIO.write(newImage, "png", outputFile);
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.buildTnThumbnail: " + ex.toString());  
		        ex.printStackTrace();
		    }
		}

		/*******************************************************************
		 * METHOD: createTnHeatmapImg
		 *
		 * This method creates the preview image using the thumbnail level info
		 * and the colormap for the first data layer.  The resulting bufferedImage
		 * will be used to construct the full thumbnail PNG.
		 ******************************************************************/
		private static void createTnHeatmapImg(ColorMap cMap, ImportData iData, Float tnMatrix[][]) {
			try {
				if (tnMatrix[0][0] != null) {
					int width = tnMatrix[0].length;
			        int height = tnMatrix.length;
			        int numBreaks = cMap.breaks.size();
			        Color lowExCol = cMap.colors.get(0);
			        Color hiExCol = cMap.colors.get(numBreaks-1);
			        Color missingCol = cMap.missingColor;
			        float lowEx = Float.parseFloat(cMap.breaks.get(0));
			        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
			        
			        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
			        
			        // BUILD HEAT MAP IMAGE
			        // go through each value in the TN matrix and determine the color for the pixel
			        for (int y = 0; y < height; y++) {
			            for (int x = 0; x < width; x++) {
			                int rgb;
			                float val = tnMatrix[y][x];
			                if (val == MIN_VALUES) {
			                	rgb = RGB_WHITE;
			                } else if (val == MAX_VALUES) {
			                	rgb = missingCol.getRGB();
			                } else {
				                if (val > hiEx){
				                    rgb = hiExCol.getRGB();
				                } else if (val < lowEx){
				                    rgb = lowExCol.getRGB();
				                } else {
				                    int i = 0;
				                    // find the breakpoints that this value is between
				                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
				                    	i++;
				                    };
				                    Color lowCol = cMap.colors.get(i-1);
				                    Color hiCol = cMap.colors.get(i);
				                    float low = Float.parseFloat(cMap.breaks.get(i-1));
				                    float hi = Float.parseFloat(cMap.breaks.get(i));
				                    float ratio = (hi-val)/(hi-low);
				                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
				                    rgb = blend.getRGB();
				                }
			                }
			                image.setRGB(x, y, rgb);
			            }
			            
			        }
			        iData.tnImage = image;
			        File outputFile = new File(iData.outputDir+File.separator + iData.chmName + "_tnMap.png"); 
			        ImageIO.write(image, "png", outputFile);
				}
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnHeatmapImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
		}
		
		
		/*******************************************************************
		 * METHOD: getSegType
		 *
		 * Helper function that figures out from the matrix whether we are
		 * drawing the left, right, or middle part of a horizontal line. Returns
		 * none if it is a vertical line element. 
		 ******************************************************************/
		private static LineSegment getSegType (int[][] matrix,  int yPos, int xPos){
			LineSegment seg = LineSegment.NONE;
			
			if (xPos > 0 && xPos < matrix[0].length-1 && matrix[yPos][xPos-1]==1 && matrix[yPos][xPos+1]==1)
				seg = LineSegment.MIDDLE;
			else if (xPos > 0 && matrix[yPos][xPos-1]==1)
				seg = LineSegment.RIGHT_END;
			else if (xPos < matrix[0].length-1 && matrix[yPos][xPos+1]==1)
				seg = LineSegment.LEFT_END;
			
			return seg;
		}
		
		/*******************************************************************
		 * METHOD: createTnColDendroPng
		 *
		 * This method creates a PNG image of the column dendrogram for a 
		 * given heat map. It is used in generating the thumbnail PNG.
		 ******************************************************************/
		private static BufferedImage createTnColDendroImg(ImportData iData, int intendedDendroWidth, int intendedDendroHeight) {
			BufferedImage image = null;
			try {
				int[][] matrix = iData.colData.dendroMatrix;
				int dendroMatrixWidth = matrix[0].length;
				int dendroMatrixHeight = matrix.length;
				
				// Create buffered image with specified dimensions
				image = new BufferedImage(intendedDendroWidth, intendedDendroHeight, BufferedImage.TYPE_INT_RGB);
				fillDendroImage(image, intendedDendroHeight, intendedDendroWidth, RGB_WHITE);
				
				//Create a scaling factor to map from dendro matrix position to the dendro png image position
				double heightScale = (double)(intendedDendroHeight-1)/(double)(dendroMatrixHeight-1);
				double widthScale = (double)(intendedDendroWidth-1)/(double)(dendroMatrixWidth-1);
				
				for (int heightPos = 0; heightPos < dendroMatrixHeight; heightPos++){
					for (int widthPos = 0; widthPos < dendroMatrixWidth; widthPos++){
						if (matrix[heightPos][widthPos] > 0) {							
							int y = (int) Math.min(Math.round((double)heightPos*heightScale), intendedDendroHeight-1);
							int x = (int) Math.min(Math.round((double)widthPos*widthScale), intendedDendroWidth-1);
							//If the png is larger than the matrix (happens for small matrices), then for horizontal lines
							//we need to draw more than 1 pixel.  When the widthScale is > 1, then we know we need to draw
							//multiple pixels.  The line segment type is also needed to do this properly.
							LineSegment seg = getSegType(matrix, heightPos, widthPos);
							setTNDendroImageValue(image, x, intendedDendroHeight-(y+1), true, (int)Math.round(widthScale), seg);
						}
					}
				}
				
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnColDendroImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
			return image;
		}	

		/*******************************************************************
		 * METHOD: createTnRowDendroPng
		 *
		 * This method creates a PNG image of the row dendrogram for a 
		 * given heat map. It is used in generating the thumbnail PNG.
		 ******************************************************************/
		private static BufferedImage createTnRowDendroImg(ImportData iData, int intendedDendroHeight, int intendedDendroWidth) {
			BufferedImage image = null;
			try {
				int[][] matrix = iData.rowData.dendroMatrix;
				int dendroMatrixWidth = matrix.length;
				int dendroMatrixHeight = matrix[0].length;

				
				// Create buffered image with specified dimensions
				image = new BufferedImage(intendedDendroWidth, intendedDendroHeight, BufferedImage.TYPE_INT_RGB);

				//Build all white image to draw lines on
		        fillDendroImage(image, intendedDendroHeight, intendedDendroWidth, RGB_WHITE);

				//Create a scaling factor to map from dendro matrix position to the dendro png image position
				double heightScale = (double)(intendedDendroHeight-1)/(double)(dendroMatrixHeight-1);
				double widthScale = (double)(intendedDendroWidth-1)/(double)(dendroMatrixWidth-1);
				
				for (int heightPos = 0; heightPos < dendroMatrixHeight; heightPos++){
					for (int widthPos = 0; widthPos < dendroMatrixWidth; widthPos++){
						if (matrix[widthPos][heightPos] > 0) {
							int y = (int)Math.min(((double)heightPos*heightScale), intendedDendroHeight-1);
							int x = (int)Math.min(((double)widthPos*widthScale), intendedDendroWidth-1);
							//If the png is larger than the matrix (happens for small matrices), then for vertical lines
							//we need to draw more than 1 pixel.  When the heightScale is > 1, then we know we need to draw
							//multiple pixels.  The line segment type is also needed to do this properly.
							LineSegment seg = getSegType(matrix, widthPos, heightPos);
							setTNDendroImageValue(image, intendedDendroWidth-x, y, false, (int)Math.round(heightScale), seg);							
						}
					}
				}
		        
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnRowDendroImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
			return image;
		}	

		/*******************************************************************
		 * METHOD: validateConfigJson
		 *
		 * This and following three methods perform a recursive zip of the heatmap directory.  
		 * that the zip file contain a folder at the top level with folder name = heat map name.
		 ******************************************************************/
		private static void zipDirectory(String zipDir, String chmName) throws Exception {
			File directoryToZip = new File(zipDir);
			File rootDir = new File(zipDir.substring(0,Math.max(zipDir.lastIndexOf(File.separator), zipDir.lastIndexOf("/"))));
			String zipFileName = zipDir + FILE_SEP + chmName + ".ngchm";
			List<File> fileList = new ArrayList<File>();
			fileList.add(directoryToZip);
			getAllFiles(directoryToZip, fileList, chmName);
			writeZipFile(rootDir, fileList, zipFileName);
		}

		private static void getAllFiles(File dir, List<File> fileList, String chmName) {
			try {
				File[] files = dir.listFiles();
				for (File file : files) {
					String fileName = file.getName();
					if (!chmName.equals(EMPTY))  { // there are some build files we don't need in the viewer zip file.  At the top level, just zip the heat map folder not other files.
						if (NGCHM_FILES.contains(fileName) || fileName.equals(chmName+" HeatMap.pdf")) {
							fileList.add(file);
						} 
					} else {
						fileList.add(file);
					}
					if (file.isDirectory()) {
						getAllFiles(file, fileList, EMPTY);
					} 
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		private static void writeZipFile(File directoryToZip, List<File> fileList, String zipFileName) {

			try {
				FileOutputStream fos = new FileOutputStream(zipFileName);
				ZipOutputStream zos = new ZipOutputStream(fos);

				for (File file : fileList) {
					if (!file.isDirectory()) { // we only zip files, not directories
						addToZip(directoryToZip, file, zos);
					}
				}
				zos.close();
				fos.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws FileNotFoundException,
		IOException {

			FileInputStream fis = new FileInputStream(file);

			// we want the zipEntry's path to be a relative path that is relative
			// to the directory being zipped, so chop off the rest of the path
			String zipFilePath = file.getCanonicalPath().substring(directoryToZip.getCanonicalPath().length() + 1,
					file.getCanonicalPath().length());
			if (zipFilePath.contains("\\"))
				zipFilePath = zipFilePath.replace("\\", "/");
			ZipEntry zipEntry = new ZipEntry(zipFilePath);
			zos.putNextEntry(zipEntry);

			byte[] bytes = new byte[1024];
			int length;
			while ((length = fis.read(bytes)) >= 0) {
				zos.write(bytes, 0, length);
			}

			zos.closeEntry();
			fis.close();
		}
		
	    private static void createHtmlHeatMap(String outputDir, String chmName) {
    		BufferedWriter  bw = null;
    		BufferedReader  br = null;
 	        try {
				String zipFileName = outputDir + FILE_SEP + chmName + ".ngchm";
	    		bw = new BufferedWriter(new FileWriter(outputDir + FILE_SEP + chmName + ".html"));
	    		String widgetPath = System.getenv("NGCHMWIDGETPATH");
				if (widgetPath == null) {
					widgetPath = "./ngchmWidget-min.js";
				}
				br = new BufferedReader(new FileReader(widgetPath ));	    		
				String htmlString1 = "<HTML><HEAD></HEAD><BODY>\n <script type='text/Javascript'>var base64_NGCHM=\"";
	    		String htmlString2 = "\"</script><div \'width: 97vh;height: 97vh;\'>\n<div id='NGCHMEmbed' style=\'display: flex; flex-direction: column; background-color: white; height: 97vh; padding: 5px;\'></div>\n</div>\n<script>\n";
	    		String htmlString3 = "</script><script type='text/Javascript'>NgChm.UTIL.embedCHM(NgChm.UTIL.b64toBlob(base64_NGCHM))</script></BODY></HTML>";
	    		String encodedNgChmFile = encodeNgChmFile(zipFileName);
 				bw.write(htmlString1);
 				bw.write(encodedNgChmFile);
 				bw.write(htmlString2);
	    		String line = br.readLine();
	    		while (line != null) {
     				bw.write(line+"\n");
	    			line = br.readLine();
	    		} 	
 				bw.write(htmlString3);
	        } catch (Exception e) {
	            e.printStackTrace();
	        } finally {
	        	try {
		    		bw.close();
		    		br.close();
	        	} catch (Exception e) {
	        		//do nothing
	        	}
	        }
		}

	    private static String encodeNgChmFile(String zipFile) throws IOException {
            String encodedBase64 = "";
	        File file = new File(zipFile);
	        byte[] bytes = new byte[(int)file.length()];
	        try {
	            DataInputStream dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(zipFile)));
	            dataInputStream.readFully(bytes);    
		        encodedBase64 = new String(Base64.getEncoder().encodeToString(bytes));
	            dataInputStream.close();
	        }
	        catch (Exception e) {
	            System.out.println("Error");
	            e.printStackTrace();
	        }
	        return encodedBase64;
	    }

}
