/*******************************************************************
 * CLASS: HeatmapDataGenerator
 *
 * This class is the driver for the heat map data generation process. 
 * import data matrix files are read in and clustered.  Data tiles, 
 * containing binary data representation of the matrix data are 
 * written out.  Finally, tile structure and column header json 
 * files are generated by the process.
 * 
 * Author: Mark Stucky
 * Date: December 14, 2015
 ******************************************************************/

package mda.ngchm.datagenerator;

import java.awt.Color;
import java.awt.Graphics; 
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.imageio.ImageIO;

import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.util.ArrayList;
import java.io.OutputStreamWriter;

import mda.ngchm.datagenerator.ImportData;
import static mda.ngchm.datagenerator.ImportConstants.*;


public class HeatmapDataGenerator {

	/*******************************************************************
	 * METHOD: main
	 *
	 * This method is the driver for the entire heat map data generation
	 * process.  
	 ******************************************************************/
	public static void main(String[] args) {
		String errMsg = processHeatMap(args);
		if ((errMsg != EMPTY) && (errMsg.contains("BUILD ERROR"))) {
			System.out.println( "ERROR in HeatmapDataGenerator e= "+ errMsg);
			System.exit(1);
		} else {
			System.exit(0);
		}
	}

	/*******************************************************************
	 * METHOD: processHeatMap
	 *
	 * An incoming JSON file is parsed to create the following
	 * data objects representing the heatmap to be generated:
	 * 1. ImportData - This object describes the entire map and holds
	 *                 all of the objects related to the map.
	 * 2. ImportFile - This object is generated for each data layer (matrix)
	 *                 data file input to the map.
	 * 3. ImportClass - This object is generated for each classification 
	 *                  (covariate) file input to the map.
	 * 4. ImportLayerData - This object is generated for each data level
	 * 					  (e.g. thumbnail, summary, etc) in the map.
	 * 5. ImportTileData - This object is generated for each data tile
	 *                   within an ImportDataLayer.
	 * 6. RowColData - This object is generated, one for rows and one for
	 *                 columns, in the map.
	 * 7. ColorMap - A colorMap object is generated for each ImportFile
	 *               and ImportClass in the map.
	 *               
	 * Once all of the above objects have been created for a heatmap, this
	 * method will generate tile files, containing binary matrix data, for
	 * each tile in the map.  Finally, the configuration JSON files 
	 * necessary for rendering the heatmap in the NGCHM viewer are 
	 * generated.
	 ******************************************************************/
	public static String processHeatMap(String[] args) {
		System.out.println("START Data Generator Heat Map Generation: " + new Date()); 
		String errMsg = EMPTY;
		       
		//Used to keep pdfBox warning messages out of the log (specifically for Galaxy)
		java.util.logging.Logger.getLogger("org.apache.pdfbox").setLevel(java.util.logging.Level.SEVERE);
		
		// Validate JSON configuration file
        try {     
        	validateConfigJson(new File(args[0]));
        } catch (Exception e) {
    		System.out.println("FATAL ERROR: Invalid heatmapProperties.JSON: " + new Date()); 
            return "BUILD ERROR: Invalid JSON Configuration.";
        } 

		// Create ImportData object for data matrix.  This object will 
		// contain subordinate objects for import layers and import tiles
		ImportData iData = null;
        try {
			iData =  new ImportData(args);
        } catch (Exception ex) {
			System.out.println("FATAL ERROR: Importing Heat Map Configuration Data. " + ex.getMessage());  
			return "BUILD ERROR: Importing Heat Map Configuration Data. " + ex.getMessage();
        }

		//Validate that all data layers are the same size.
        if (iData.matrixFiles.size() > 1) {
        	try {
            	MatrixValidator.validateDataLayersSize(iData.matrixFiles);
        	} catch (Exception ex) {
    			errMsg = "BUILD ERROR: Data Layer Input - " + ex.getMessage();
    			System.out.println(errMsg);  
    	        return errMsg;
        	}
        }

		ImportLayerData summaryLayer = null;
		try {
			for (int i=0; i < iData.matrixFiles.size(); i++) {
				summaryLayer = writeTileFiles(iData, i);
			}
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing Tile Data - " + ex.getMessage();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}

		//Create configuration files for heatmap viewer
		try {
			writeMapDataFile(iData, summaryLayer);
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing mapData.JSON Configuration File: " + ex.toString();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}
		try {
			writeMapConfigFile(iData);
		} catch (Exception ex) {
			errMsg = "BUILD ERROR: Writing mapConfig.JSON Configuration File: " + ex.toString();
			System.out.println(errMsg);  
	        ex.printStackTrace();
	        return errMsg;
		}
		
		//Thumbnail PNG
        InputFile iFile = iData.matrixFiles.get(0);
		try {
    	    createTnHeatmapImg(iFile.getMap(), iData, iData.tnMatrix);
			buildTnThumbnail(iData);
		} catch (Exception e) {
			System.out.println("Error generating thumbnail image: " + e.toString());  
		}

		//Generate PDF
        if ((iData.generatePDF) && (iData.readMatrices.equals(YES))) {
        	boolean fullPDF = false;
			try {
	        	for (int i=0; i < iData.matrixFiles.size();i++) {
			        iFile = iData.matrixFiles.get(i);
			        if (iData.pdfMatrices !=null) {
			        	createSummaryImg(iFile.getMap(), iData, iData.pdfMatrices.get(i));
			        }
	        	}
		        int size = iData.pdfMatrices.get(0).length;
	        	for (int i=0; i < iData.rowData.classFiles.size();i++) {
	        		InputClass iClass = iData.rowData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.rowData.createTopItemsImg(iData.rowData.classArray.length - 1);
				size = iData.pdfMatrices.get(0)[0].length;
	        	for (int i=0; i < iData.colData.classFiles.size();i++) {
	        		InputClass iClass = iData.colData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.colData.createTopItemsImg(iData.colData.classArray.length - 1);
				PdfGenerator pGen = new PdfGenerator();
				if (iData.rowData.dendroMatrix != null) {
					iData.rowData.dendroImage = createRowDendroImg(iData, new Float(5.5));
				}
				if (iData.colData.dendroMatrix != null) {
					iData.colData.dendroImage = createColDendroImg(iData, new Float(5.5));
				}
				pGen.createHeatmapPDF(iData, fullPDF); 
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating PDF: " + ex.toString());  
				ex.printStackTrace();
			}
        } else if (iData.generateFullPDF) { 
        	boolean fullPDF = true;
			try {
	        	for (int i=0; i < iData.matrixFiles.size();i++) {
			        iFile = iData.matrixFiles.get(i);
			        if (iData.pdfMatrices !=null) {
			        	createDetailImg(iFile.getMap(), iData, iData.pdfMatrices.get(i));
			        }
	        	}
		        int size = iData.pdfMatrices.get(0).length;
	        	for (int i=0; i < iData.rowData.classFiles.size();i++) {
	        		InputClass iClass = iData.rowData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.rowData.createTopItemsImg(iData.rowData.classArray.length - 1);
				size = iData.pdfMatrices.get(0)[0].length;
	        	for (int i=0; i < iData.colData.classFiles.size();i++) {
	        		InputClass iClass = iData.colData.classFiles.get(i);
	        		iClass.createClassSummaryImg(size);
	        		iClass.createClassLegendImg();
	        	}
        		iData.colData.createTopItemsImg(iData.colData.classArray.length - 1);
				PdfGenerator pGen = new PdfGenerator();
				if (iData.rowData.dendroMatrix != null) {
					Float sizeTo = new Float( new Float(iData.rowData.dendroMatrix[0].length*5-1)/ new Float(120));  // mapWidth divided by 120 to get inch width of map. 120 is a bit of a fudge factor to try to figure out how many points per inch on the PDF
					iData.rowData.dendroImage = createRowDendroImg(iData, sizeTo);
				}
				if (iData.colData.dendroMatrix != null) {
					Float sizeTo = new Float( new Float((iData.colData.dendroMatrix[0].length*5-1))/ new Float(120));  // mapWidth divided by 120 to get inch width of map, x65% to get approximate size on page
					iData.colData.dendroImage = createColDendroImg(iData, sizeTo);
				}
				pGen.createHeatmapPDF(iData, fullPDF); 
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating PDF: " + ex.toString());  
				ex.printStackTrace();
			}
        }
		//Generate zipped .ngchm file
        if (iData.generateNGCHM) {
        	try {
        		zipDirectory(iData.outputDir, iData.chmName);
			} catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.main. Error generating NGCHM zip file: " + ex.toString());  
				ex.printStackTrace();
			}
        }

		if (iData.rowData.configWarnings.size() > 0) {
			for (int i=0;i<iData.rowData.configWarnings.size();i++) {
				errMsg = errMsg + iData.rowData.configWarnings.get(i) + "\n";
			}
		}
		if (iData.colData.configWarnings.size() > 0) {
			for (int i=0;i<iData.colData.configWarnings.size();i++) {
				errMsg = errMsg + iData.colData.configWarnings.get(i) + "\n";
			}
		}
		System.out.println("END Heat Map Generation: " + new Date()); 
		return errMsg;
	}
	
	/*******************************************************************
	 * METHOD: validateConfigJson
	 *
	 * This method parses the heatmapProperties JSON file to validate
	 * its contents. 
	 ******************************************************************/
	private static void validateConfigJson(File config) throws Exception {
		// Validate JSON configuration file
		FileReader configFile = new FileReader(config);
		try {     
	        JSONParser parser = new JSONParser();
	        parser.parse(configFile);
	        configFile.close();
	    } catch (FileNotFoundException ex) {
	        System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: heatmapProperties.JSON file not found." );
			ex.printStackTrace();
	        throw ex;
	    } catch (IOException ex) {
	        System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: IO Exception reading heatmapProperties.JSON file.");
			ex.printStackTrace();
	        throw ex;
	   } catch (ParseException ex) {
			System.out.println("Exception in HeatmapDataGenerator.validateConfigJson: Invalid Heatmap Configuration."); 
	        ex.printStackTrace();
	        throw ex;
	   } finally {
		   configFile.close();
		   configFile = null;
	   }
	}
	
	/*====================================================================
	 * BEGIN: DATA TILE FILE WRITING METHODS
	 *
	 * The methods that follow are concerned with writing out data tile
	 * output files to the various tile "level" output directories.
	 *====================================================================*/

	/*******************************************************************
	 * METHOD: writeTileFiles
	 *
	 * This method writes out all data tile files for a map by iterating 
	 * thru the ImportDataLayers and calling the writeTileFile method for
	 * each tile in each layer. 
	 ******************************************************************/
	private static ImportLayerData writeTileFiles(ImportData iData, int position) throws Exception {
		ImportLayerData summaryLayer = null;
		try {
			// Loop thru ImportData object processing for each ImportDataLayer
			InputFile iFile = iData.matrixFiles.get(position);
			float[][] clusteredMatrix = iFile.getReorderedInputMatrix(iData.rowData, iData.colData);

			if (iFile.map.colors.isEmpty()) {
				iFile.map = ColorMapGenerator.getDefaultMapColors(iFile, clusteredMatrix);
			}
			if (iData.generateFullPDF) {
				iFile.createDistributionLegendImg(clusteredMatrix);
			}
			ArrayList<ImportLayerData> iLayers = iFile.importLayers;
			for (int i=0; i < iLayers.size(); i++) {
				ImportLayerData ilData = iLayers.get(i);
				// Create thumbnail float value array for ONLY the first data layer processed.
				if (ilData.layer.equals(LAYER_THUMBNAIL)) {
					if (iFile.position.equals("DataLayer1")) {
						iData.tnMatrix = new Float[ilData.rowsPerTile][ilData.colsPerTile];
					}
					if (!iFile.hasSummary) {
						iData.pdfMatrices.add(new Float[ilData.rowsPerTile][ilData.colsPerTile]);
					}
				}
				if (ilData.layer.equals(LAYER_SUMMARY) && (iData.generatePDF)) {
					iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
				}
				else if (iData.generateFullPDF) {
					// if it has detail tiles, use those, if not revert to summary. if not summary, then thumbnail
					if (ilData.layer.equals(LAYER_THUMBNAIL) && !iFile.hasSummary) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					} else if (ilData.layer.equals(LAYER_SUMMARY) && !iFile.hasDetail) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					} else if (ilData.layer.equals(LAYER_DETAIL)) {
						iData.pdfMatrices.add(new Float[ilData.totalLevelRows][ilData.totalLevelCols]);
					}
				}
				
				if (ilData.layer.equals(LAYER_SUMMARY)) {
					summaryLayer = ilData;
				}
				String dlDir = "dl"+(position+1);
		    	File dataDir = new File(iData.outputDir+File.separator+dlDir+File.separator+ilData.layer);
		    	if (!dataDir.exists()) {
		    		if ((iData.writeTiles.equals(NO)) || (iData.writeTiles.equals(NO))) {
		    			System.out.println("BUILD ERROR: write_tiles or read_matrices is set to NO and tile directory does not exist.  Cannot continue processing heat map.");
		    			return null;
		    		}
		    	}
		    	
				if (iData.readMatrices.equals(YES)) {
					// Within each ImportDataLayer, loop thru each of its 
					// ImportTileData objects writing out a tile for each
					for (int j=0; j < ilData.importTiles.size(); j++){
						ImportTileData itData = ilData.importTiles.get(j);
						writeTileFile(iData, ilData, itData, position, clusteredMatrix);
					}
				}
			}
			if (DEBUG) {
				writeClusteredDebugFile(iData, iFile, clusteredMatrix, (position+1));
			}
	    	clusteredMatrix = null;
	    	System.gc();
		} catch (Exception ex) {
	    	System.out.println("Exception writing tile files: "+ ex.toString());
			throw ex;
		}
		return summaryLayer;
	}
	
	/*******************************************************************
	 * METHOD: writeTileFile
	 *
	 * This method writes out individual data tile files by iterating 
	 * thru the data matrix string array, stored on the ImportData object,
	 * and writing out individual binary float values using the ImportLayerData 
	 * and ImportTileData objects as a guideline.
	 ******************************************************************/
	private static void writeTileFile(ImportData iData, ImportLayerData ilData, ImportTileData itData, int position, float[][] clusteredMatrix) throws Exception {
		BufferedOutputStream write = null;
	    try {
			InputFile iFile = iData.matrixFiles.get(position);
			String dlDir = "dl"+(position+1);

			//If tile destination dir does not exist, create directory.
	    	File dataDir = new File(iData.outputDir+File.separator+dlDir+File.separator+ilData.layer);
	    	if (!dataDir.exists()) {
	    		dataDir.mkdirs();
	    	} 
//	    	boolean writeTiles = true;
//			File tileFile = new File(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName);
//			if (tileFile.exists()) {
//				writeTiles = getOrderDendroFileDate(iData) < tileFile.lastModified() ? false : true;
//			}
	        
			if (iData.writeTiles.equals(YES)) {
				write = new BufferedOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName));
			}
			int rowStart = itData.rowStartPos, rowEnd = itData.rowEndPos;
			int colStart = itData.colStartPos, colEnd = itData.colEndPos; 
			int rowInterval = ilData.rowInterval, colInterval = ilData.colInterval;
			int nextColWrite = 0;
			int nextRowWrite = getNextRowWrite(ilData, rowStart);
			int nextCol = getNextColWrite(ilData, colStart);
			DataOutputStream writeRow=null;
			if (DEBUG) { writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+itData.fileName + TXT_FILE));  }//For debugging: writes out file
			int rowctr = 0;
			int colctr = 0;
			for (int row = rowStart; row < rowEnd; row++) {
				if (row == nextRowWrite) {
					nextColWrite = nextCol;
					String valprint = null;
					if (DEBUG) { valprint = Integer.toString(row); } //For debugging: writes out file
					for (int col = colStart; col < colEnd; col++) {
						if (col == nextColWrite) {
							float v = getMatrixValue(iData,ilData,iFile,row,col,clusteredMatrix); 
							if (ilData.layer.equals(LAYER_THUMBNAIL)) {
								if (iFile.position.equals("DataLayer1")) {
									iData.tnMatrix[rowctr][colctr] = v;
								}
								if (!iFile.hasSummary) {
									iData.pdfMatrices.get(position)[rowctr][colctr] = v;
								}
							}
							if (ilData.layer.equals(LAYER_SUMMARY) && (iData.generatePDF)) {
								int rowPos = itData.rowStartPos == 1 ? rowctr : ilData.rowsPerTile + rowctr;
								int colPos = itData.colStartPos == 1 ? colctr : ilData.colsPerTile + colctr;
								iData.pdfMatrices.get(position)[rowPos][colPos] = v;
							} else if (iData.generateFullPDF) {
								if (ilData.layer.equals(LAYER_THUMBNAIL) && !iFile.hasSummary) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if (ilData.layer.equals(LAYER_SUMMARY) && !iFile.hasDetail) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : ilData.rowsPerTile + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : ilData.colsPerTile + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if (ilData.layer.equals(LAYER_DETAIL)) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart - 1 + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart - 1 + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								} else if ((ilData.layer.equals(LAYER_RIBBONVERT) || ilData.layer.equals(LAYER_RIBBONHORIZ)) && !iFile.hasDetail) {
									int rowPos = itData.rowStartPos == 1 ? rowctr : rowStart + rowctr;
									int colPos = itData.colStartPos == 1 ? colctr : colStart + colctr;
									iData.pdfMatrices.get(position)[rowPos][colPos] = v;
								}
							}
							byte f[] = ByteBuffer.allocate(4).putFloat(v).array();
							if (DEBUG) { valprint = valprint + TAB + v; } //For debugging: writes out file
							if (iData.writeTiles.equals(YES)) {
								write.write(f, 3, 1);
								write.write(f, 2, 1);
								write.write(f, 1, 1);
								write.write(f, 0, 1); 
							}
							nextColWrite += colInterval;
							colctr++;
						}
					}
					if (DEBUG) { 
						valprint = valprint + "\r\n";  //For debugging: writes out file
						writeRow.writeChars(valprint); 
					} 
					nextRowWrite += rowInterval;
					rowctr++;
					colctr = 0;
				} 
			}
	    	if (DEBUG) { writeRow.close(); } //For debugging: writes out file
	    } catch (NumberFormatException ex) {
	    	System.out.println("Exception in HeatmapDataGenerator.writeTileFile: Non-numeric data found in matrix "+ ex.toString());
	       throw ex;
	    } finally {
			if (write != null) {
				write.close();
			}
	    }
	}
	
	/*******************************************************************
	 * METHOD: getMatrixValue
	 *
	 * This method retrieves the matrix value to be written out to a given
	 * data tile. If the sampling method of "sample" is being used, the 
	 * value associated with the row/col passed in is returned. If the 
	 * sampling method is "average" or "predominance" an array is populated 
	 * containing all of the values in the range of the current value based
	 * upon the row/col intervals.  If the method is average, the value 
	 * returned will be the average of all values in the array. If the 
	 * method is "predominance", the value that re-occurs the most in the
	 * array is returned. 
	 ******************************************************************/
	private static float getMatrixValue(ImportData iData, ImportLayerData ilData, InputFile iFile, int row, int col, float[][] clusteredMatrix) throws Exception
	{  
	  float value = 0;
	  if (iFile.summaryMethod.equals(METHOD_SAMPLE)) {
		  value = clusteredMatrix[row][col];
	  }	else  {
		  int rowInter = ilData.rowInterval;
		  int colInter = ilData.colInterval;
		  if (rowInter+colInter == 2) {
			  value = clusteredMatrix[row][col];
		  } else {
			  //We must check if we are going past the max row/cols and adjust the 
			  //boundary for our loop AND the interval value that will be used for averaging.
			  int rowBoundary = row+ilData.rowInterval;
			  int colBoundary = col+ilData.colInterval;
			  if (rowBoundary>= clusteredMatrix.length) {
				  rowBoundary = clusteredMatrix.length;
				  rowInter = rowBoundary - row;
			  }
			  if (colBoundary>= clusteredMatrix[0].length) {
				  colBoundary = clusteredMatrix[0].length;
				  colInter = colBoundary - col;
			  }
			  int combInter = (rowInter*colInter);
			  float[] valArr = new float[combInter];
			  int valArrIdx = 0;
			  // Grab all values in the prescribed bounded range and place them in an array
			  for (int i = row; i < rowBoundary;i++) {
				  for (int j = col; j < colBoundary;j++) {
					  valArr[valArrIdx] = clusteredMatrix[i][j];
					  valArrIdx++;
				  }
			  }
			  if (iFile.summaryMethod.equals(METHOD_AVERAGE)) {
				  value = getAverageValue(valArr, combInter);  
			  } else if (iFile.summaryMethod.equals(METHOD_MODE)) {
				  value = getPredominantValue(valArr);
			  }
		  }
	  }	
	  return value;  
	}
	
	/*******************************************************************
	 * METHOD: getAverageValue
	 *
	 * This method iterates thru the array passed, in summing all of the
	 * values contained therein. That value is then divided by the 
	 * combined row/col interval.  HIGH VALUES are factored out UNLESS
	 * they represent every data element in the block being averaged.
	 ******************************************************************/
	private static float getAverageValue(float[] array, int combInter) throws Exception {
		float retVal = 0;
		float value = 0;
		boolean allCut = true;
		// sum the values in the array
		for (int k = 0; k < array.length; k++) {
			if ((array[k] != MAX_VALUES) && (array[k] != MIN_VALUES)) {
				value = value + array[k];
			} else {
				if (array[k] != MIN_VALUES) {
					allCut = false;
				}
				combInter--;
			}
		}
		//If at least one value in the array is not a max/cut value, average and return.
		if (combInter != 0) {
			retVal = value / combInter;
		} else {
			//If all values to be averaged are cut values, return the cut value
			if (allCut) {
				retVal =  MIN_VALUES;
			} else {
				retVal =  MAX_VALUES;
			}
		}
		return retVal;
	}
	
	/*******************************************************************
	 * METHOD: getPredominantValue
	 *
	 * This method iterates thru the array passed in, summing the 
	 * number occurrences of each value in the array and returns the 
	 * value with the most occurrences. If more than one value occurs the 
	 * same amount of times, the first value encountered is returned.
	 ******************************************************************/
	private static float getPredominantValue(float[] array) throws Exception {
		float value = 0;
        ArrayList<Float> distinctVals = new ArrayList<>();
        // loop original array adding distinct values to ArrayList
        for(int i= 0; i< array.length; i++) {
            boolean found = false;
            float iVal = array[i];
            // loop distinct values to see if current value already exists
            for (int v =0; v<distinctVals.size(); v++) {
                if(distinctVals.get(v)==iVal) {
                  found = true;
                  break;
                }
            }
            // add distinct value to ArrayList is not found
            if (!found) {
            	distinctVals.add(iVal);
            }
        }
        // create array for storing counts based on number of distinct values
        int [] arrayIndex= new int[distinctVals.size()];
        // loop distinct values array
        for(int i= 0; i< distinctVals.size(); i++) {
            int count = 0;
            // loop original array, counting occurrences of distinct value.
            for (int v =0; v<array.length; v++) {
                if(array[v] == distinctVals.get(i)) {
                  count++;
                }
            }
            arrayIndex[i] = count;
        }
        int highOcc = 0;
        int highIdx = 0;
        // Loop occurrences count array and set the index value
        // of the distinct value that has the most occurrences.
        for(int i= 0; i < arrayIndex.length; i++) {
        	int occ = arrayIndex[i];
        	if (occ > highOcc) {
        		highOcc = occ;
        		highIdx = i;
        	}
        }
        value = distinctVals.get(highIdx);
        return value;
    }

	/*******************************************************************
	 * METHOD: getNextRowWrite
	 *
	 * A helper method calculating the next row to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon horizontal layer views.
	 ******************************************************************/
	private static int getNextRowWrite(ImportLayerData ilData, int rowStart) throws Exception {	
		int nextRowWrite = rowStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONHORIZ).contains(ilData.layer)) {
			if ((rowStart != 1) && (ilData.rowInterval != 1)) {
				nextRowWrite = (((rowStart/ilData.rowInterval)*ilData.rowInterval)+1);
			}
		} 
		return nextRowWrite;
	}

	/*******************************************************************
	 * METHOD: getNextColWrite
	 *
	 * A helper method calculating the next column to write when beginning
	 * a new tile.  This is only used when an interval is being used
	 * for thumbnail, summary, and ribbon vertical layer views.
	 ******************************************************************/
	private static int getNextColWrite(ImportLayerData ilData, int colStart) throws Exception {	
		int nextColWrite = colStart;
		if (Arrays.asList(LAYER_THUMBNAIL, LAYER_SUMMARY, LAYER_RIBBONVERT).contains(ilData.layer)) {
			if ((colStart != 1) && (ilData.colInterval != 1)) {
				nextColWrite = (((colStart/ilData.colInterval)*ilData.colInterval)+1);
			}
		} 
		return nextColWrite;
	}

	/*====================================================================
	 * END: TILE WRITING METHODS
	 *==================================================================*/


	/*====================================================================
	 * BEGIN: OUTPUT FILE WRITING METHODS
	 *
	 * The methods that follow, from here to the end of the file, write
	 * the various output files generated by the HeatmapDataGenerator 
	 * process.  They include:
	 * 1. The mapData.JSON file containing supporting data for the map
	 * 2. The mapConfig.JSON file containing configurationd data for the map
	 *
	 * START: mapData.JSON file writing methods
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeMapDataFile
	 *
	 * This method is the main driver for the generation of the 
	 * mapData.JSON file.  It creates an output stream writer for the file
	 * using the output directory specified for the heatMap.  Then the 
	 * rowData and colData JSON subschemas are written to the file. The 
	 * rowData subschema contains row label data, row dendrogram data, and
	 * row classification (covariate) data.  The colData subschem contains
	 * similar data for the heatMap columns.
	 ******************************************************************/
   	private static void writeMapDataFile(ImportData iData, ImportLayerData summaryLayer) throws Exception {
		DataOutputStream writer = null;
		OutputStreamWriter fw = null;
		try {
			writer = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+MAP_DATA_FILE));
			fw = new OutputStreamWriter(writer, UTF8);
			//Write out row_data JSON section
	        fw.write(BRACE_OPEN+ROWDATA_LABEL+BRACE_OPEN);
	        writeLabels(fw, iData, true);
	        writeDataDendrogram(fw, iData, true);
	        writeDataClassifications(fw, iData, summaryLayer, true);
	        fw.write(BRACE_CLOSE+BRACE_CLOSE+COMMA);
			//Write out col_data JSON section
	        fw.write(COLDATA_LABEL+BRACE_OPEN);
	        writeLabels(fw, iData, false);
	        writeDataDendrogram(fw, iData, false);
	        writeDataClassifications(fw, iData, summaryLayer, false); 
	        fw.write(BRACE_CLOSE+BRACE_CLOSE+BRACE_CLOSE);
	    } catch (Exception ex) {
			System.out.println("Exception Writing mapData.JSON file: " + ex.toString());  
	        throw ex;
	    } finally {
			fw.close();
			writer.close();
	    }
	}
			
	/*******************************************************************
	 * METHOD: writeLabels
	 *
	 * This method writes out the colLabels and rowLabels JSON subschema
	 * data to the mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  The reOrgMatrix 2-D string array 
	 * stored on the ImportData object is traversed pulling either row or 
	 * column headers from the matrix in clustered order.
	 ******************************************************************/
	private static void writeLabels(OutputStreamWriter w, ImportData iData, boolean isRowFile) throws Exception {	
		// Build String constants
		// Loop thru import layers and write out structure data for each.
		if (isRowFile) {
			//Sometimes label hidden fields are loaded from a separate file into this hash.  Otherwise it will be empty.
			HashMap<String, String> extraLabelInfo = loadExtraLabel(iData.rowData.labelExtraFile);
		    w.write(LABEL_LABEL+BRACE_OPEN+LABEL_TYPE_LABEL+BRACKET_OPEN);
		    //Write data types - can be more than one.
		    for (int i = 0; i < iData.rowData.dataTypes.length; i++) { 
		    	w.write(QUOTE+iData.rowData.dataTypes[i]+QUOTE);
		    	if (i < iData.rowData.dataTypes.length-1) w.write(COMMA);
		    }
		    w.write(BRACKET_CLOSE+COMMA+LABELS_LABEL+BRACKET_OPEN);
	        for (int row = 1; row < iData.rowData.classArray.length; row++) {
	        	String initLabel = iData.rowData.classArray[row].equals(CUT_VALUE) ? "" : iData.rowData.classArray[row];
	        	String label = addExtra(initLabel, extraLabelInfo);
        	    w.write(QUOTE+label+QUOTE);
				if (row < (iData.rowData.classArray.length-1)) {
					w.write(COMMA);
				}
	        }
		} else {
			//Sometimes label hidden fields are loaded from a separate file into this hash.  Otherwise it will be empty.
			HashMap<String, String> extraLabelInfo = loadExtraLabel(iData.colData.labelExtraFile);
		    w.write(LABEL_LABEL+BRACE_OPEN+LABEL_TYPE_LABEL+BRACKET_OPEN);
		    //Write data types - can be more than one.
		    for (int i = 0; i < iData.colData.dataTypes.length; i++) { 
		    	w.write(QUOTE+iData.colData.dataTypes[i]+QUOTE);
		    	if (i < iData.colData.dataTypes.length-1) w.write(COMMA);
		    }
		    w.write(BRACKET_CLOSE+COMMA+LABELS_LABEL+BRACKET_OPEN);
	        for (int col = 1; col < iData.colData.classArray.length; col++) {
	        	String initLabel = iData.colData.classArray[col].equals(CUT_VALUE) ? "" : iData.colData.classArray[col];
	        	String label = addExtra(initLabel, extraLabelInfo);
        	    w.write(QUOTE+label+QUOTE);
				if (col < (iData.colData.classArray.length-1)) {
					w.write(COMMA);
				}
	        }
		}
		w.write(BRACKET_CLOSE+BRACE_CLOSE);
	}
	
	/*******************************************************************
	 * METHOD: loadExtraLabel
	 * 
	 * In some situations, the hidden label information (pipe delimited
	 * info on row/column labels that is not visible in the browser) is
	 * not included in the data matrix but is provided as a separate file.
	 * This method reads the info from the separate file into a HashMap
	 * so it can be used when writing labels.
	 * 
	 * Extra label file is tab delimited with first column being the row/column
	 * label from the matrix and the second column being the string to append
	 * to the label with the '|' character.
	 *******************************************************************/
	private static HashMap<String, String> loadExtraLabel(String extraLabelFile) throws Exception {
		HashMap<String, String> extraLabelInfo = new HashMap<String, String>();
		if (extraLabelFile != null ) {
			BufferedReader br = new BufferedReader(new FileReader(extraLabelFile));
			//For now assume extra label file has no header.
			String line = br.readLine();
			while (line != null) {
				String toks[] = line.split("\t");
				if (toks.length == 2)
					extraLabelInfo.put(toks[0].trim(), toks[1].trim());

				line = br.readLine();
			}
			br.close();

		}
		return extraLabelInfo;
	}
	
	/*******************************************************************
	 * METHOD: addExtra
	 * 
	 * Helper method to lookup and add extra hidden fields to labels.
	 ******************************************************************/
	private static String addExtra(String label, HashMap<String, String> extraLabelInfo) throws Exception {
		// To accommodate tree cuts in data with blank label
		if (label == null) {
			label = EMPTY;
		} 
		//Add extra label information for labels that apply
		int pipeIdx = label.indexOf(PIPE);
		String visibleLabel = pipeIdx > 0 ? label.substring(0, pipeIdx) : label;
		if (extraLabelInfo.containsKey(visibleLabel)) {
			label = (label + PIPE + extraLabelInfo.get(visibleLabel));
		}
		return label;
	}
	
	/*******************************************************************
	 * METHOD: writeDendrogram
	 *
	 * This method writes out the dendrogram JSON subschema data to the 
	 * mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  A check is performed for 
	 * row/col to determine if a dendrogram exists.  If one is found a 
	 * second method is called that writes out the dendrogram data for
	 * the row/col to mapData.
	 ******************************************************************/
	private static void writeDataDendrogram(OutputStreamWriter fw, ImportData iData, boolean isRowFile) throws Exception {
		if (isRowFile) {
			if (iData.rowData.dendroFile != null) {
				populateDendrogramData(iData.rowData.dendroValues, fw, iData);
				fw.write(BRACKET_CLOSE);
	        }
		} else {
	        if (iData.colData.dendroFile!= null) {
				populateDendrogramData(iData.colData.dendroValues, fw, iData);
				fw.write(BRACKET_CLOSE);
	        }
		}
	}
	
	/*******************************************************************
	 * METHOD: populateDendrogramData
	 *
	 * This method writes out the dendrogram JSON subschema data to the 
	 * mapData.JSON file. A given row/col dendrogram file is traversed
	 * and data is written out to an outputStreamWriter for the mapData
	 * JSON file.
	 ******************************************************************/
	private static void populateDendrogramData(List<String> dendroValues, OutputStreamWriter fw, ImportData iData) throws Exception {
        boolean firstTimeThrough = true;
        fw.write(COMMA+DENDROGRAM_LABEL+BRACKET_OPEN);
        for (int i=0; i<dendroValues.size();i++) {
            if (firstTimeThrough){
                firstTimeThrough = false;
            } else {
                fw.write(COMMA);
            }
            String dendroLineData = dendroValues.get(i);
            fw.write(QUOTE+dendroLineData+QUOTE);
        }
	}
	/*******************************************************************
	 * METHOD: writeClassifications
	 *
	 * This method writes out the classificaton (covariate) JSON subschema 
	 * data to the mapData.JSON file. A boolean is passed in to differentiate 
	 * between the two during processing.  A check is performed for 
	 * row/col to determine if a classification exists.  If one is found, the
	 * data is re-ordered into clustered order to match the re-ordered matrix
	 * data and then a second method is called that writes out the classification 
	 * data for the row/col to mapData.
	 ******************************************************************/
	private static void writeDataClassifications(OutputStreamWriter fw, ImportData iData, ImportLayerData ilData, boolean isRowFile) throws Exception {
		int rowInterval = (ilData!=null) ? ilData.rowInterval : 1;
		int colInterval = (ilData!=null) ? ilData.colInterval : 1;
        fw.write(COMMA+CLASSIFICATIONS_LABEL+BRACE_OPEN);
        if (isRowFile) {
			if (iData.rowData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.rowData.classFiles.size();i++) {
		        	InputClass currInput = iData.rowData.classFiles.get(i);
		        	populateClassifications(currInput, currInput.orderedClass, fw, rowInterval, isRowFile);
	        		fw.write(BRACE_CLOSE);
		        	if (i != iData.rowData.classFiles.size() - 1) {
		        		fw.write(COMMA);
		        	}
		        } 
			} 
        } else {
			if (iData.colData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.colData.classFiles.size();i++) {
		        	InputClass currInput = iData.colData.classFiles.get(i);
		        	populateClassifications(currInput, currInput.orderedClass, fw, colInterval, isRowFile);
	        		fw.write(BRACE_CLOSE);
		        	if (i != iData.colData.classFiles.size() - 1) {
		        		fw.write(COMMA);
		        	}
		        } 
			}
        }
	}
	
	/*******************************************************************
	 * METHOD: populateClassifications
	 *
	 * This method writes out the classification JSON subschema data to the 
	 * mapData.JSON file. The re-ordered classification data passed into
	 * this method is traversed and data is written out to an outputStreamWriter 
	 * for the mapData JSON file.  If more than summary level data exists
	 * for the heatMap, a second subschema (svalues) that is sampled at
	 * the summary level using the summary interval, is written to the
	 * JSON file in addition to the values subschema.
	 ******************************************************************/
	private static void populateClassifications(InputClass currFile, String classData[], OutputStreamWriter fw, int interval, boolean isRowFile) throws Exception {
        fw.write(QUOTE+currFile.name+QUOTE+COLON+LINE_FEED+BRACE_OPEN);
        fw.write(QUOTE+"values"+QUOTE+COLON+LINE_FEED+TAB+TAB+BRACKET_OPEN);
        boolean isDiscrete = currFile.map.type.equals(COLORTYPE_DISCRETE) ? true : false;
        // Write out a separate "values" node containing values for the classification file
        for (int row = 1; row < classData.length; row++) {
        	writeClassValue(classData[row], row, classData.length, fw, 1, isDiscrete);
        }
        // Write out a separate "svalues" node containing values for the classification file
        // this dataset will be sampled at the same level as the summary layer.
        if (interval > 1) {
        	int sValen = (classData.length-1)/interval;
        	float remn = ((float)classData.length-1)/interval%1;
        	if (remn > 0) {
        		sValen++;
        	}
    		String sValArr[] = new String[sValen+1];
    		int sValCtr = 0;
	        fw.write(COMMA+QUOTE+"svalues"+QUOTE+COLON+LINE_FEED+BRACKET_OPEN);
	        float aggrVal = 0;
	        int cutCtr = 0;
	        for (int row = 1; row < classData.length; row++) {
	        	int adjustedPos = row - 1;
	    		float remainder = ((float)adjustedPos/interval)%1;
	    		String dataItem = classData[row] == null ? "NA" : classData[row];
	    		if (currFile.map.type.equals(COLORTYPE_CONTINUOUS)) {
	    			if (dataItem.equals(CUT_VALUE) || NA_VALUES.contains(dataItem)) {
	    				cutCtr++;
	    			} else {
	    				aggrVal = aggrVal+Float.parseFloat(dataItem);
	    			}
	    		}
	    		if (remainder == 0) {
		    		if (currFile.map.type.equals(COLORTYPE_CONTINUOUS)) {
		    			if ((aggrVal == 0) && (dataItem.equals(CUT_VALUE) || NA_VALUES.contains(dataItem))) {
			    			writeClassValue(dataItem, row, classData.length, fw, interval, isDiscrete);
		    			} else {
			    			String avgVal = Float.toString(aggrVal/(interval-cutCtr));
			    			writeClassValue(avgVal, row, classData.length, fw, interval, isDiscrete);
		    			}
		    		} else {
		    			writeClassValue(dataItem, row, classData.length, fw, interval, isDiscrete);
		    		}
		        	sValCtr++;
		        	sValArr[sValCtr] = classData[row];
		        	aggrVal = 0;
		        	cutCtr = 0;
	    		} 
	        }
        } 
    	fw.write(LINE_FEED);
	}
	
	/*******************************************************************
	 * METHOD: writeClassValue
	 *
	 * This is a utility method used by populateClassifications to
	 * write out string and numeric values to the classifications subschema
	 * in the mapData.JSON file. 
	 ******************************************************************/
	private static void writeClassValue(String val, int row, int len, OutputStreamWriter fw, int interval, boolean discrete) throws Exception {
		fw.write(QUOTE+val+QUOTE);
    	if (row+interval < len) {
    		fw.write(COMMA);
    	} else {
    		fw.write(BRACKET_CLOSE);
    	}
	}
	
	/*====================================================================
	 * END: mapData.JSON file writing methods
	 * 
	 * START: mapConfig.JSON file writing methods
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeMapConfigFile
	 *
	 * This method is the main driver for the generation of the 
	 * mapConfig.JSON file.  It creates an output stream writer for the file
	 * using the output directory specified for the heatMap.  Then the 
	 * data_configuration, row_configuration, and col_configuration JSON 
	 * subschemas are written to the file. The data_configuration subschema
	 * contains the following JSON subschemas:
	 * 1. map_information: Containing global configuration for the map
	 * 2. levels: Containing data level (eg thumbnail, summary, etc) 
	 *            configuration for the map.
	 * 3. data_layer: Containing data layer (flick) configuration for the map.

	 * The row_configuration and col_configuration subschemas contain the 
	 * following JSON subschemas for row/col configuration:	   
	 * 1. organization: Containing ordering (clustering) configuration for map.
	 * 2. dendrogram: Containing dendrogram configuration for the map. 
	 * 3. classifications: Containing classification (covariate) configuration 
	 *                     for the map. 
	 ******************************************************************/
   	private static void writeMapConfigFile(ImportData iData) throws Exception {
		DataOutputStream writer = null;
		OutputStreamWriter fw = null;
		try {
			writer = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+MAP_CONFIG_FILE));
			fw = new OutputStreamWriter(writer, UTF8);
			//Write out data configuration JSON section
	        fw.write(BRACE_OPEN+DATA_CONFIG_LABEL+BRACE_OPEN);
	        writeMapInformation(fw, iData);
	        writeMapStructure(fw, iData);
	        writeDataLayers(fw, iData);
	        fw.write(BRACE_CLOSE);
	        fw.write(BRACE_CLOSE+COMMA);
			//Write out column configuration JSON section
	        fw.write(ROW_CONFIG_LABEL+BRACE_OPEN);
	        writeTopItems(fw, iData, true);
	        writeOrganization(fw, iData, true);
	        writeLabelConfig(fw, iData, true);
	        writeConfigDendrogram(fw, iData, true);
	        writeConfigClassifications(fw, iData, true);
	        fw.write(BRACE_CLOSE+COMMA);
			//Write out row configuration JSON section
	        fw.write(COL_CONFIG_LABEL+BRACE_OPEN);
	        writeTopItems(fw, iData, false);
	        writeOrganization(fw, iData, false);
	        writeLabelConfig(fw, iData, false);
	        writeConfigDendrogram(fw, iData, false);
	        writeConfigClassifications(fw, iData, false);
	        fw.write(BRACE_CLOSE+BRACE_CLOSE);
	    } catch (Exception ex) {
			System.out.println("Exception Writing mapConfig.JSON file: " + ex.toString());  
	        throw ex;
	    } finally {
	    	fw.close();
	    	writer.close();
	    }
	}
				           
	/*******************************************************************
	 * METHOD: writeMapInformation
	 *
	 * This method writes out the map_information JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file. Configuration
	 * data for the heatmap name, description, and any attributes provided
	 * to the builder are written out.
	 ******************************************************************/
	private static void writeMapInformation(OutputStreamWriter fw, ImportData iData)  throws Exception {
        fw.write(MAP_INFO_LABEL+BRACE_OPEN);
        fw.write(NAME_LABEL+QUOTE+iData.chmName+QUOTE+COMMA);
        fw.write(DESC_LABEL+QUOTE+iData.chmDescription+QUOTE+COMMA);
        fw.write(BUILDER_VER_LABEL+QUOTE+iData.builderVersion+QUOTE+COMMA);
        fw.write(READ_ONLY_LABEL+QUOTE+iData.readOnly+QUOTE+COMMA);
        fw.write(VERSION_LABEL+QUOTE+CURRENT_GENERATOR_VERSION+QUOTE+COMMA);
        fw.write(LABEL_LENGTH_LABEL+LABEL_LENGTH_DEFAULT+COMMA);
        fw.write(LABEL_TRUNCATION_LABEL+LABEL_TRUNCATE_DEFAULT+COMMA);
        fw.write(SUMMARY_WIDTH_LABEL+QUOTE+iData.summaryWidth+QUOTE+COMMA);
        fw.write(SUMMARY_HEIGHT_LABEL+QUOTE+iData.summaryHeight+QUOTE+COMMA);
        fw.write(DETAIL_WIDTH_LABEL+QUOTE+iData.detailWidth+QUOTE+COMMA);
        fw.write(DETAIL_HEIGHT_LABEL+QUOTE+iData.detailHeight+QUOTE+COMMA);
        int cutRows = iData.rowData.cutLocations.length*iData.rowData.cutWidth;
        int cutCols = iData.colData.cutLocations.length*iData.colData.cutWidth;
        fw.write(MAP_CUT_ROWS_LABEL+QUOTE+cutRows+QUOTE+COMMA);
        fw.write(MAP_CUT_COLS_LABEL+QUOTE+cutCols+QUOTE+COMMA);
        fw.write(ATTRS_LABEL+BRACE_OPEN);
        for (int i=0;i<iData.chmAttributes.size();i++) {
        	AttributeData ad = iData.chmAttributes.get(i);
	        fw.write(QUOTE+ad.attributeName+QUOTE+COLON+QUOTE+ad.attributeValue+QUOTE);
        	if (i != (iData.chmAttributes.size() - 1)) {
        		fw.write(COMMA);
        	}
        } 
        fw.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeMapStructure
	 *
	 * This method writes out the levels JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file.	 This 
	 * subschema contains the tile structure for the heatmap. A thumb will 
	 * always be written.  The levels  below will be written to the file if 
	 * they are generated.
	 ******************************************************************/
	private static void writeMapStructure(OutputStreamWriter w, ImportData iData)  throws Exception {	
		InputFile iFile = iData.matrixFiles.get(0);
		w.write(LEVELS_LABEL+BRACE_OPEN);
		// Loop thru import layers and write out structure data for each.
		for (int i=0; i < iFile.importLayers.size(); i++) {
			ImportLayerData ilData = iFile.importLayers.get(i);
			// Write out the Thumbnail file structure data.
			w.write(QUOTE+ilData.layer+QUOTE+COLON);
			w.write(BRACE_OPEN);
			w.write(TILEROWS_LABEL+ilData.rowTiles);
			w.write(COMMA+TILECOLS_LABEL+ilData.colTiles);
			w.write(COMMA+TILEROWSPER_LABEL+ilData.rowsPerTile);
			w.write(COMMA+TILECOLSPER_LABEL+ilData.colsPerTile);
			w.write(COMMA+TOTALROWS_LABEL+ilData.totalLevelRows);
			w.write(COMMA+TOTALCOLS_LABEL+ilData.totalLevelCols);
			w.write(COMMA+ROW_SUMMARY_RATIO_LABEL+ilData.rowInterval);
			w.write(COMMA+COL_SUMMARY_RATIO_LABEL+ilData.colInterval);
			w.write(BRACE_CLOSE);
			if (i < (iFile.importLayers.size() - 1)) {
				w.write(COMMA);
			}
		}
		w.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeDataLayers
	 *
	 * This method writes out the data_layer JSON subschema of the 
	 * data_configuration subschema of the mapConfig.JSON file.	 This 
	 * subschema contains a configuration for each matrix file (primary and
	 * flicks) in the heatmap. This method starts writing the subschema, 
	 * placing the data layer id and name in the subschema, and then calls
	 * a method to write the colormap configuration for the data layer into
	 * the mapConfig.JSON file.
	 ******************************************************************/
	private static void writeDataLayers(OutputStreamWriter fw, ImportData iData)  throws Exception {	
        fw.write(DATA_LAYER_LABEL+BRACE_OPEN);
		// Build String constants
		for (int i=0; i < iData.matrixFiles.size(); i++) {
			InputFile iFl = iData.matrixFiles.get(i);
			fw.write(QUOTE+iFl.id+QUOTE+COLON+BRACE_OPEN);
			fw.write(NAME_LABEL+QUOTE+iFl.name+QUOTE+COMMA);
			fw.write(GRID_SHOW_LABEL+QUOTE+iFl.gridShow+QUOTE+COMMA);
			fw.write(GRID_COLOR_LABEL+QUOTE+iFl.gridColor+QUOTE+COMMA);
			fw.write(CUTS_COLOR_LABEL+QUOTE+iFl.cutsColor+QUOTE+COMMA);
			fw.write(SELECTION_COLOR_LABEL+QUOTE+iFl.selectionColor+QUOTE+COMMA);
			writeColorMap(fw, iData, i, DATA_LAYER_LABEL);
			fw.write(BRACE_CLOSE);
			
			if (i < iData.matrixFiles.size() - 1) {
				fw.write(COMMA);
			}
		}
		fw.write(BRACE_CLOSE);
	}	

	/*******************************************************************
	 * METHOD: writeColorMap
	 *
	 * This method writes out the colorMap JSON subschema of the 
	 * data_layers AND classifications subschemas of the mapConfig.JSON file.	 
	 ******************************************************************/
	private static void writeColorMap(OutputStreamWriter fw, ImportData iData, int filePos, String mapType)  throws Exception {
		ColorMap cMap = null;
		if (DATA_LAYER_LABEL.equals(mapType)) {
	        InputFile iFile = iData.matrixFiles.get(filePos);
	        cMap = iFile.getMap();
		} else {
	        InputClass iFile;
			if (ROW_CONFIG_LABEL.equals(mapType)) {
		        iFile = iData.rowData.classFiles.get(filePos);
			} else {
				iFile = iData.colData.classFiles.get(filePos);
			} 
	        cMap = iFile.getMap();
	    }
        fw.write(cMap.asJSON());
	}	
	
	/*******************************************************************
	 * METHOD: writeOrganization
	 *
	 * This method writes out the organization JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is used to drive the This subschema contains the row/col organization configuration 
	 * for the heatmap.
	 ******************************************************************/
	private static void writeOrganization(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		// Build String constants
		fw.write(ORGANIZATION_LABEL+BRACE_OPEN);
		// Loop thru import layers and write out structure data for each.
		if (isRowFile) {
		    String rowOrderMethod = iData.rowData.orderMethod;
		    fw.write(ORDER_METHOD_LABEL+QUOTE+rowOrderMethod+QUOTE+COMMA);
		    if (ORDER_HIERARCHICAL.equals(rowOrderMethod)) {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+iData.rowData.agglomerationMethod+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+iData.rowData.distanceMetric+QUOTE);
		    } else {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+NONE+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+NONE+QUOTE);
		    }
		} else {
		    String cowOrderMethod = iData.colData.orderMethod;
		    fw.write(ORDER_METHOD_LABEL+QUOTE+cowOrderMethod+QUOTE+COMMA);
		    if (ORDER_HIERARCHICAL.equals(cowOrderMethod)) {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+iData.colData.agglomerationMethod+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+iData.colData.distanceMetric+QUOTE);
		    } else {
		    	fw.write(AGGLOMERATION_LABEL+QUOTE+NONE+QUOTE+COMMA);
		    	fw.write(DISTANCE_METRIC_LABEL+QUOTE+NONE+QUOTE);
		    }
		}
		fw.write(BRACE_CLOSE+COMMA);
	}	
	
	/*******************************************************************
	 * METHOD: writeLabelConfig
	 *
	 * This method writes out label configuration data to the mapConfig
	 * JSON file. Configuration data written includes the maximum display
	 * length for a label and the method for abbreviating that label.
	 ******************************************************************/
	private static void writeLabelConfig(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		RowColData data = iData.rowData;
		if (!isRowFile) {
			data = iData.colData;
		}
	    fw.write(LABEL_LENGTH_LABEL+QUOTE+data.labelMaxLength+QUOTE+COMMA);
	    fw.write(LABEL_ABBREV_METHOD_LABEL+QUOTE+data.labelAbbrevMethod+QUOTE+COMMA);
	}	

	/*******************************************************************
	 * METHOD: writeTopItems
	 *
	 * This method writes out top row/column label items to the mapConfig
	 * JSON file.  These items are defined by the incoming heatmapConfig
	 * JSON file and are used to display specific "top" labels on the
	 * Summary heatmap in the viewer application.
	 ******************************************************************/
	private static void writeTopItems(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {	
		String[] topItems = iData.rowData.topItems;
		if (!isRowFile) {
			topItems = iData.colData.topItems;
		}
	    fw.write(TOP_ITEMS_LABEL+BRACKET_OPEN);
		if (topItems != null) {
			for (int i=0;i<topItems.length;i++) {
				fw.write(QUOTE+topItems[i]+QUOTE);
				if (i < topItems.length-1) {
					fw.write(COMMA);
				}
			}
		}
		fw.write(BRACKET_CLOSE+COMMA);
	}	
	
	/*******************************************************************
	 * METHOD: writeConfigDendrogram
	 *
	 * This method writes out the dendrogram JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is passed in to differentiate between the two during 
	 * processing. This subschema contains the dendrogram configuration 
	 * for the heatmap.
	 ******************************************************************/
	private static void writeConfigDendrogram(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {
        fw.write(DENDROGRAM_LABEL+BRACE_OPEN);
		if (isRowFile) {
	        if (iData.rowData != null) {
		        fw.write(SHOW_LABEL+QUOTE+iData.rowData.showDendro+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+iData.rowData.heightDendro+QUOTE); 
	        } else {
		        fw.write(SHOW_LABEL+QUOTE+"NA"+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+"10"+QUOTE); 
	        }
		} else {
	        if (iData.colData.dendroFile!= null) {
		        fw.write(SHOW_LABEL+QUOTE+iData.colData.showDendro+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+iData.colData.heightDendro+QUOTE); 
	        } else {
		        fw.write(SHOW_LABEL+QUOTE+"NA"+QUOTE+COMMA); 
		        fw.write(HEIGHT_LABEL+QUOTE+"10"+QUOTE); 
	        }
		}
        fw.write(BRACE_CLOSE+COMMA);
	}
	
	/*******************************************************************
	 * METHOD: writeConfigClassifications
	 *
	 * This method writes out the classification (covariate) JSON subschema of the 
	 * row_configuration and col_configuration subschemas of the mapConfig.JSON 
	 * file.  A boolean is passed in to differentiate between the two during 
	 * processing. This subschema contains the classification configuration
	 * variable and colormap for the heatmap.
	 ******************************************************************/
	private static void writeConfigClassifications(OutputStreamWriter fw, ImportData iData, boolean isRowFile)  throws Exception {
        fw.write(CLASSIFICATIONS_LABEL+BRACE_OPEN);
		String classOrder = BRACKET_OPEN;
		if (isRowFile) {
			if (iData.rowData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.rowData.classFiles.size();i++) {
		        	InputClass currInput = iData.rowData.classFiles.get(i);
		        	classOrder += QUOTE+currInput.name+QUOTE;
					fw.write(QUOTE+currInput.name+QUOTE+COLON+BRACE_OPEN);
					fw.write(HEIGHT_LABEL+QUOTE+currInput.height+QUOTE+COMMA);
					fw.write(SHOW_LABEL+QUOTE+currInput.show+QUOTE+COMMA);
			        fw.write(BAR_TYPE_LABEL+QUOTE+currInput.barType+QUOTE+COMMA);
			        if (currInput.dataType != null) {
				        fw.write(DATA_TYPE_LABEL+QUOTE+currInput.dataType+QUOTE+COMMA);
			        }
			        fw.write(FG_COLOR_LABEL+QUOTE+currInput.fgColor+QUOTE+COMMA);
			        fw.write(BG_COLOR_LABEL+QUOTE+currInput.bgColor+QUOTE+COMMA);
			        fw.write(LOW_BOUND_LABEL+QUOTE+currInput.lowBound+QUOTE+COMMA);
			        fw.write(HIGH_BOUND_LABEL+QUOTE+currInput.highBound+QUOTE+COMMA);
					writeColorMap(fw, iData, i,ROW_CONFIG_LABEL);
					if (i < iData.rowData.classFiles.size() - 1) {
			        	classOrder += COMMA;
						fw.write(BRACE_CLOSE+COMMA);
					} else {
						fw.write(BRACE_CLOSE);
					}
		        }
			}
		} else {
			if (iData.colData.classFiles.size() == 0) {
				fw.write(EMPTY);
			} else {
		        for (int i=0;i<iData.colData.classFiles.size();i++) {
		        	InputClass currInput = iData.colData.classFiles.get(i);
		        	classOrder += QUOTE+currInput.name+QUOTE;
					fw.write(QUOTE+currInput.name+QUOTE+COLON+BRACE_OPEN);
					fw.write(HEIGHT_LABEL+QUOTE+currInput.height+QUOTE+COMMA);
					fw.write(SHOW_LABEL+QUOTE+currInput.show+QUOTE+COMMA);
			        fw.write(BAR_TYPE_LABEL+QUOTE+currInput.barType+QUOTE+COMMA);
			        if (currInput.dataType != null) {
				        fw.write(DATA_TYPE_LABEL+QUOTE+currInput.dataType+QUOTE+COMMA);
			        }
			        fw.write(FG_COLOR_LABEL+QUOTE+currInput.fgColor+QUOTE+COMMA);
			        fw.write(BG_COLOR_LABEL+QUOTE+currInput.bgColor+QUOTE+COMMA);
			        fw.write(LOW_BOUND_LABEL+QUOTE+currInput.lowBound+QUOTE+COMMA);
			        fw.write(HIGH_BOUND_LABEL+QUOTE+currInput.highBound+QUOTE+COMMA);
					writeColorMap(fw, iData, i,COL_CONFIG_LABEL);
					if (i < iData.colData.classFiles.size() - 1) {
			        	classOrder += COMMA;
						fw.write(BRACE_CLOSE+COMMA);
					} else {
						fw.write(BRACE_CLOSE);
					}
		        }
			}
		}
        fw.write(BRACE_CLOSE+COMMA);
        classOrder += BRACKET_CLOSE;
        fw.write(CLASSIFICATIONS_ORDER_LABEL+classOrder);
	}
	
	/*====================================================================
	 * END: mapConfig.JSON file writing methods
	 * 
	 * END OUTPUT FILE WRITING METHODS
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: writeClusteredDebugFile
	 *
	 * This method is for debugging.  It writes out the clustered
	 * data matrix to a file called clustered.txt in the matrix data dir.
	 ******************************************************************/
	private static void writeClusteredDebugFile(ImportData iData, InputFile iFile, float[][] clusteredMatrix, int fileNo) {	
		DataOutputStream writeRow = null;
		OutputStreamWriter w = null;
		try {
			String dlDir = "dl"+fileNo;
			writeRow = new DataOutputStream(new FileOutputStream(iData.outputDir+File.separator+dlDir+File.separator+"clustered.txt"));
			w = new OutputStreamWriter(writeRow, UTF8);
	        for (int row = 0; row < clusteredMatrix.length; row++) {
		        for (int col = 0; col < clusteredMatrix[0].length; col++) {
		        	float val = clusteredMatrix[row][col];
		        	w.write(String.valueOf(val));
					if (col < (clusteredMatrix[0].length-1)) {
						w.write(TAB);
					} else {
						w.write(LINE_FEED);
					}
		        }
	        }
			w.close();
			writeRow.close();
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.writeClusteredDebugFile: " + ex.toString());  
	        ex.printStackTrace();
	    } finally {
	    	try {
	    		w.close();
	    		writeRow.close();
	    	} catch (Exception ex) { /* Do nothing FOR NOW */ }
	    }
	}
	
	/*====================================================================
	 * BEGIN IMAGE CREATION METHODS USED IN GENERATING THUMBNAIL IMAGES
	 * AND THE HEAT MAP PDF.
	 *==================================================================*/
	
	/*******************************************************************
	 * METHOD: createSummaryImg
	 *
	 * This method creates the preview image using the summary level info
	 * and the color map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static void createSummaryImg(ColorMap cMap, ImportData iData, Float sumMatrix[][]){
		try {
			int width = sumMatrix[0].length;
	        int height = sumMatrix.length;
	        int numBreaks = cMap.breaks.size();
	        Color lowExCol = cMap.colors.get(0);
	        Color hiExCol = cMap.colors.get(numBreaks-1);
	        Color missingCol = cMap.missingColor;
	        float lowEx = Float.parseFloat(cMap.breaks.get(0));
	        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
	        
	        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	        
	        // BUILD HEAT MAP IMAGE
	        // go through each value in the SUMMARY matrix and determine the color for the pixel
	        for (int y = 0; y < height; y++) {
	            for (int x = 0; x < width; x++) {
	                float val = sumMatrix[y][x];
	                int rgb;
	                if (val == MIN_VALUES) {
	                	rgb = RGB_WHITE;
	                } else if (val == MAX_VALUES) {
	                	rgb = missingCol.getRGB();
	                } else {
		                if (val > hiEx){
		                    rgb = hiExCol.getRGB();
		                } else if (val < lowEx){
		                    rgb = lowExCol.getRGB();
		                } else {
		                    int i = 0;
		                    // find the breakpoints that this value is between
		                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
		                    	i++;
		                    };
		                    Color lowCol = cMap.colors.get(i-1);
		                    Color hiCol = cMap.colors.get(i);
		                    float low = Float.parseFloat(cMap.breaks.get(i-1));
		                    float hi = Float.parseFloat(cMap.breaks.get(i));
		                    float ratio = (hi-val)/(hi-low);
		                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
		                    rgb = blend.getRGB();
		                }
	                }
	                image.setRGB(x, y, rgb);
	            }
	        }
			iData.matrixImages.add(image);
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createSummaryImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: createDetailImg
	 *
	 * This method creates the preview image using the summary level info
	 * and the color map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static void createDetailImg(ColorMap cMap, ImportData iData, Float detMatrix[][]){
		try {
			int width = detMatrix[0].length;
	        int height = detMatrix.length;
	        int numBreaks = cMap.breaks.size();
	        Color lowExCol = cMap.colors.get(0);
	        Color hiExCol = cMap.colors.get(numBreaks-1);
	        Color missingCol = cMap.missingColor;
	        float lowEx = Float.parseFloat(cMap.breaks.get(0));
	        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
	        
	        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	        
	        // BUILD HEAT MAP IMAGE
	        // go through each value in the Detail matrix and determine the color for the pixel
	        for (int y = 0; y < height; y++) {
	            for (int x = 0; x < width; x++) {
	                float val = detMatrix[y][x];
	                int rgb;
	                if (val == MIN_VALUES) {
	                	rgb = RGB_WHITE;
	                } else if (val == MAX_VALUES) {
	                	rgb = missingCol.getRGB();
	                } else {
		                if (val > hiEx){
		                    rgb = hiExCol.getRGB();
		                } else if (val < lowEx){
		                    rgb = lowExCol.getRGB();
		                } else {
		                    int i = 0;
		                    // find the breakpoints that this value is between
		                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
		                    	i++;
		                    };
		                    Color lowCol = cMap.colors.get(i-1);
		                    Color hiCol = cMap.colors.get(i);
		                    float low = Float.parseFloat(cMap.breaks.get(i-1));
		                    float hi = Float.parseFloat(cMap.breaks.get(i));
		                    float ratio = (hi-val)/(hi-low);
		                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
		                    rgb = blend.getRGB();
		                }
	                }
	                image.setRGB(x, y, rgb);
	            }
	        }
			iData.matrixImages.add(image);
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createDetailImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: createColDendroImg
	 *
	 * This method creates a PNG image of the column dendrogram for a 
	 * given heat map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static BufferedImage createColDendroImg(ImportData iData, Float sizeTo) {
		BufferedImage image = null;
		try {
			int dendroWidth = iData.colData.dendroMatrix[0].length;
			int dendroHeight = iData.colData.dendroMatrix.length;
			//This factor reduces the dendro size to the number of inches on a BufferedImage divides by 5.5 
			//to determine how many values to factor to make the dendro approximately 5.5 inches wide
			Float lowSample = new Float(new Float(dendroWidth)/120)/sizeTo;
			boolean lowSampInd = false;
			if (lowSample < .5) {
				lowSampInd = true;
			}
			Float sampleFactor = new Float(Math.round((dendroWidth/120)/sizeTo));
			sampleFactor = sampleFactor > 0 ? sampleFactor : 1;
			if (lowSampInd) {
				sampleFactor = new Float(Math.round(1/lowSample));
				//Set sampling factor to an even number
				if ((sampleFactor%2)!=0) sampleFactor--;
				//Factor up the width of the image
				dendroWidth *= sampleFactor;
			} else {
				//Factor down the width of the image
				dendroWidth /= sampleFactor;
				
			}
	        image = new BufferedImage(dendroWidth, dendroHeight, BufferedImage.TYPE_INT_RGB);
	        //Build all white image to draw lines on
	        fillDendroImage(image, dendroHeight, dendroWidth, RGB_WHITE);
           	//Draw lines on the image
	        if (lowSampInd) {
	        	drawDendroImageLinesUpScale(image, iData.colData.dendroMatrix, dendroHeight, sampleFactor, COL);
	        } else {
	        	drawDendroImageLines(image, iData.colData.dendroMatrix, dendroHeight, sampleFactor, COL);
	        }
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createColDendroImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
		return image;
	}
	
	/*******************************************************************
	 * METHOD: createRowDendroImg
	 *
	 * This method creates a PNG image of the row dendrogram for a 
	 * given heat map. It is used in generating the heat map PDF.
	 ******************************************************************/
	private static BufferedImage createRowDendroImg(ImportData iData, Float sizeTo){
		BufferedImage image = null;
		try {
			int dendroWidth = iData.rowData.dendroMatrix[0].length;
			int dendroHeight = iData.rowData.dendroMatrix.length;
			//This factor reduces the dendro size to the number of inches on a BufferedImage divides by 5.5 
			//to determine how many values to factor to make the dendro approximately 5.5 inches tall
			Float lowSample = new Float(new Float(dendroWidth)/120)/new Float(sizeTo);
			boolean lowSampInd = false;
			if (lowSample < .5) {
				lowSampInd = true;
			}
			Float sampleFactor = new Float(Math.round((dendroWidth/120)/sizeTo)); 
			sampleFactor = sampleFactor > 0 ? sampleFactor : 1;
			if (lowSampInd) {
				sampleFactor = new Float(Math.round(1/lowSample));
				//Set sampling factor to an even number
				if ((sampleFactor%2)!=0) sampleFactor--;
				//Factor up the width of the image
				dendroWidth *= sampleFactor;
			} else {
				//Factor down the width of the image
				dendroWidth /= sampleFactor;
			}
	        image = new BufferedImage(dendroHeight, dendroWidth, BufferedImage.TYPE_INT_RGB);
	        //Build all white image to draw lines on
	        fillDendroImage(image, dendroWidth, dendroHeight, RGB_WHITE);
           	//Draw lines on the image
	        if (lowSampInd) {
	        	drawDendroImageLinesUpScale(image, iData.rowData.dendroMatrix, dendroHeight, sampleFactor, ROW);
	        } else {
	        	drawDendroImageLines(image, iData.rowData.dendroMatrix, dendroHeight, sampleFactor, ROW);
	        }
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.createRowDendroImg: " + ex.toString());  
	        ex.printStackTrace();
	    }
		return image;
	}	
	
	
	/*******************************************************************
	 * METHOD: fillDendroImage
	 *
	 * This method fills a prospective dendrogram BuffereImage with white
	 * space and is configurable for drawing on both Row and Column images.
	 ******************************************************************/
	public static void fillDendroImage(BufferedImage image, int dendroHeight, int dendroWidth, int fillColor)  {
		try {
		    //Build all white image to draw lines on
			for (int i = 0; i < dendroHeight; i++) {
				for (int j=0; j < dendroWidth; j++) {
		                image.setRGB(j, dendroHeight-(i+1), fillColor);
		 		}
			}
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.fillDendroImage: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}

	/*******************************************************************
	 * METHOD: drawDendroImageLines
	 *
	 * This method draws dendrogram lines on a BufferedImage and is 
	 * configurable for drawing both Row and Column lines.  It is utilized
	 * when the dendro image being created is smaller than the dendro matrix.
	 * Thus, the image is down-scaled.
	 ******************************************************************/
	private static void drawDendroImageLines(BufferedImage image, int[][] dendroMatrix, int dendroHeight, Float sampleFactor, String type) {
		try {
	       	//Draw lines on the image
	       	for (int i = 0; i < dendroHeight; i++) {
	    		int[] dendroRow = dendroMatrix[i];
	    		int sample = 0;
	    		int sampleSum = 0;
	    		int samplePos = 0;
	    		int jPos = 0;
	    		for (int j=0; j < dendroRow.length; j++) {
	    			if (sample < sampleFactor) {
	    				sampleSum += dendroRow[samplePos];
	        			samplePos++;
	        			sample++;
	    			} 
	    			if (sample == sampleFactor) {
	    				if (sampleSum > 0) {
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1)); //Draw
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos); //Draw
	    					}
	    				}
	    				sample = 0;
	    				sampleSum = 0;
	    				jPos++;
	    			}
	    		}
	    	} 
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.drawDendroImageLines: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: drawDendroImageLinesUpScale
	 *
	 * This method draws dendrogram lines on a BufferedImage and is 
	 * configurable for drawing both Row and Column lines.  It is utilized
	 * when the dendro image being created is larger than the dendro matrix.
	 * Thus, the image is up-scaled.
	 ******************************************************************/
	private static void drawDendroImageLinesUpScale(BufferedImage image, int[][] dendroMatrix, int dendroHeight, Float sampleFactor, String type) {
		try {
	       	//Draw lines on the image
			boolean lastWasSelected = false;
			 for (int i = 0; i < dendroHeight; i++) {
	    		int[] dendroRow = dendroMatrix[i];
	    		int jPos = 0;
	    		for (int j=0; j < dendroRow.length; j++) {
	    			int sampleVal = dendroRow[j];
	    			if (sampleVal == 1) {
	    				if (lastWasSelected) {
	    					//back up 1/2 a position and draw for 1 full position
	    					jPos -= sampleFactor/2;
	    					for (int k = 0; k < sampleFactor; k++) {
	        					if (type.equals(COL)) {
	        						setDendroImageValue(image, jPos, dendroHeight-(i+1));
	        					} else {
	        						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	        					}
	    						jPos++;
	    					}
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1));
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	    					}
	    					jPos += sampleFactor/2;
	    				} else {
	    					//draw one dot in the middle of one full position
		    				jPos += sampleFactor/2;
	    					if (type.equals(COL)) {
	    						setDendroImageValue(image, jPos, dendroHeight-(i+1)); //Draw
	    					} else {
	    						setDendroImageValue(image, dendroHeight-(i+1), jPos);
	    					}
		    				jPos += sampleFactor/2;
	    				}
	    				lastWasSelected = true;
	    			} else {
	    				//skip one full position
	    				lastWasSelected = false;
	    				jPos += sampleFactor;
	    			}
	    		}
	   		} 
	    } catch (Exception ex) {
			System.out.println("Exception in HeatmapDataGenerator.drawDendroImageLinesUpScale: " + ex.toString());  
	        ex.printStackTrace();
	    }
	}
	
	/*******************************************************************
	 * METHOD: setDendroImageValue
	 *
	 * This method sets a black pixel on the submitted x/y coordinates
	 * in a BufferedImage containing a row/col dendrogram.
	 ******************************************************************/
	private static void setDendroImageValue(BufferedImage image, int x, int y) {
		try {
			image.setRGB(x, y, RGB_BLACK);	
		} catch (Exception e) {
			// Do nothing - for logging: System.out.println("setImageValue exception x: " + x + " y: " + y);
		}
	}
	
	/*******************************************************************
	 * METHOD: setTNDendroImageValue
	 *
	 * This method sets a black pixel on the submitted x/y coordinates
	 * in a BufferedImage containing a row/col dendrogram. This is an advanced
	 * version of the function that handles widths and line end conditions for
	 * special processing in the thumbnail image.
	 ******************************************************************/
	private static void setTNDendroImageValue(BufferedImage image, int x, int y, boolean columnDendro, int width, LineSegment seg) {
		try {
			if (columnDendro) {
				int start = x;
				int stop = x + 1;
				if (width > 1) {
					if (seg == LineSegment.MIDDLE) {
						start -= width/2;
						stop += width/2;
					} else if (seg == LineSegment.LEFT_END) {
						stop += width/2;
					} else if (seg == LineSegment.RIGHT_END) {
						start -= width/2;
					}
				}
				for (int xPos = start; xPos < stop; xPos++){
					image.setRGB(xPos, y, RGB_BLACK);
				}	
			} else {
				int start = y;
				int stop = y + 1;
				if (width > 1) {
					if (seg == LineSegment.MIDDLE) {
						start -= width/2;
						stop += width/2;
					} else if (seg == LineSegment.LEFT_END) {
						start -= width/2;
					} else if (seg == LineSegment.RIGHT_END) {
						stop += width/2;
					}
				}
				for (int yPos = start; yPos < stop; yPos++){
					image.setRGB(x, yPos, RGB_BLACK);
				}	
			}
		} catch (Exception e) {
			// Do nothing - for logging: System.out.println("setImageValue exception x: " + x + " y: " + y);
		}
	}

	/*==========================
	 * THUMBNAIL SPECIFIC LOGIC
	 *=========================*/

	/*******************************************************************
	 * METHOD: buildTnThumbnail
	 *
	 * This method constructs the completed thumbnail PNG from buffered
	 * images generated for the row/col dendros and the heat map.
	 ******************************************************************/
	 public static void buildTnThumbnail(ImportData iData) {
	        //do some calculate first
	        int offset  = 1;
	        int finalDendH = TN_HEIGHT;
	        Graphics g = null;
	        try {
				//BufferedImage rDScale = null;
				BufferedImage rDendImg = null;
				int rDendHgt = 0;
				if (iData.rowData.dendroMatrix != null) {
			        // Build scaled row dendro image for thumbnail
					rDendImg = createTnRowDendroImg(iData, TN_WIDTH, TN_HEIGHT);
					rDendHgt = rDendImg.getHeight();
				}
				//BufferedImage cDScale = null;
				BufferedImage cDendImg = null;
				int cDendWid = 0;
				if (iData.colData.dendroMatrix != null) {
			        // Build scaled column dendro image for thumbnail
					cDendImg = createTnColDendroImg(iData, TN_WIDTH, TN_HEIGHT);
					cDendWid = cDendImg.getWidth();
				}
	
				//Calculate total image height/width for thumbnail
				int imgWid = cDendWid > 0 ? cDendWid : TN_WIDTH+TN_HEIGHT;
				int imgHgt = rDendHgt > 0 ? rDendHgt : TN_WIDTH+TN_HEIGHT;
				int imgWDiff = 5;
				int imgHDiff = 5;
				
		        //Build scaled heat map image for thumbnail
		        BufferedImage hmImg = iData.tnImage;
		        BufferedImage hmScale = new BufferedImage(imgWid, imgHgt, BufferedImage.TYPE_INT_RGB);
				g = hmScale.createGraphics();
				g.drawImage(hmImg, 0, 0, imgWid, imgHgt, null);
				
				g.dispose();
		        
		        // Create a new buffer for completed thumbnail image
		        BufferedImage newImage = new BufferedImage(TN_THUMB_WIDTH,TN_THUMB_WIDTH, BufferedImage.TYPE_INT_ARGB);
		        
		        Graphics2D g2 = newImage.createGraphics();
		        Color oldColor = g2.getColor();
		        
		        // Fill background of thumbnail with white
		        g2.setPaint(Color.WHITE);
		        g2.fillRect(0, 0, TN_THUMB_WIDTH, TN_THUMB_WIDTH);
		        
		        // Draw thumbnail image from heat map and dendros
		        g2.setColor(oldColor);
		        g2.drawImage(rDendImg, null, imgWDiff, imgHDiff+finalDendH+offset);
		        g2.drawImage(cDendImg, null, imgWDiff+finalDendH+offset, imgHDiff);
		        g2.drawImage(hmScale, null, imgWDiff+finalDendH+offset, imgHDiff+finalDendH+offset);
		        g2.dispose();
		        File outputFile = new File(iData.outputDir+File.separator + iData.chmName + "_tn.png"); 
		        ImageIO.write(newImage, "png", outputFile);
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.buildTnThumbnail: " + ex.toString());  
		        ex.printStackTrace();
		    }
		}

		/*******************************************************************
		 * METHOD: createTnHeatmapImg
		 *
		 * This method creates the preview image using the thumbnail level info
		 * and the colormap for the first data layer.  The resulting bufferedImage
		 * will be used to construct the full thumbnail PNG.
		 ******************************************************************/
		private static void createTnHeatmapImg(ColorMap cMap, ImportData iData, Float tnMatrix[][]) {
			try {
				if (tnMatrix[0][0] != null) {
					int width = tnMatrix[0].length;
			        int height = tnMatrix.length;
			        int numBreaks = cMap.breaks.size();
			        Color lowExCol = cMap.colors.get(0);
			        Color hiExCol = cMap.colors.get(numBreaks-1);
			        Color missingCol = cMap.missingColor;
			        float lowEx = Float.parseFloat(cMap.breaks.get(0));
			        float hiEx = Float.parseFloat(cMap.breaks.get(numBreaks-1));
			        
			        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
			        
			        // BUILD HEAT MAP IMAGE
			        // go through each value in the TN matrix and determine the color for the pixel
			        for (int y = 0; y < height; y++) {
			            for (int x = 0; x < width; x++) {
			                int rgb;
			                float val = tnMatrix[y][x];
			                if (val == MIN_VALUES) {
			                	rgb = RGB_WHITE;
			                } else if (val == MAX_VALUES) {
			                	rgb = missingCol.getRGB();
			                } else {
				                if (val > hiEx){
				                    rgb = hiExCol.getRGB();
				                } else if (val < lowEx){
				                    rgb = lowExCol.getRGB();
				                } else {
				                    int i = 0;
				                    // find the breakpoints that this value is between
				                    while (Float.parseFloat(cMap.breaks.get(i)) <= val && i < numBreaks-1){
				                    	i++;
				                    };
				                    Color lowCol = cMap.colors.get(i-1);
				                    Color hiCol = cMap.colors.get(i);
				                    float low = Float.parseFloat(cMap.breaks.get(i-1));
				                    float hi = Float.parseFloat(cMap.breaks.get(i));
				                    float ratio = (hi-val)/(hi-low);
				                    Color blend = ColorMapGenerator.blendColors(hiCol,lowCol,ratio);
				                    rgb = blend.getRGB();
				                }
			                }
			                image.setRGB(x, y, rgb);
			            }
			            
			        }
			        iData.tnImage = image;
			        File outputFile = new File(iData.outputDir+File.separator + iData.chmName + "_tnMap.png"); 
			        ImageIO.write(image, "png", outputFile);
				}
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnHeatmapImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
		}
		
		
		/*******************************************************************
		 * METHOD: getSegType
		 *
		 * Helper function that figures out from the matrix whether we are
		 * drawing the left, right, or middle part of a horizontal line. Returns
		 * none if it is a vertical line element. 
		 ******************************************************************/
		private static LineSegment getSegType (int[][] matrix,  int yPos, int xPos){
			LineSegment seg = LineSegment.NONE;
			
			if (xPos > 0 && xPos < matrix[0].length-1 && matrix[yPos][xPos-1]==1 && matrix[yPos][xPos+1]==1)
				seg = LineSegment.MIDDLE;
			else if (xPos > 0 && matrix[yPos][xPos-1]==1)
				seg = LineSegment.RIGHT_END;
			else if (xPos < matrix[0].length-1 && matrix[yPos][xPos+1]==1)
				seg = LineSegment.LEFT_END;
			
			return seg;
		}
		
		/*******************************************************************
		 * METHOD: createTnColDendroPng
		 *
		 * This method creates a PNG image of the column dendrogram for a 
		 * given heat map. It is used in generating the thumbnail PNG.
		 ******************************************************************/
		private static BufferedImage createTnColDendroImg(ImportData iData, int intendedDendroWidth, int intendedDendroHeight) {
			BufferedImage image = null;
			try {
				int[][] matrix = iData.colData.dendroMatrix;
				int dendroMatrixWidth = matrix[0].length;
				int dendroMatrixHeight = matrix.length;
				
				// Create buffered image with specified dimensions
				image = new BufferedImage(intendedDendroWidth, intendedDendroHeight, BufferedImage.TYPE_INT_RGB);
				fillDendroImage(image, intendedDendroHeight, intendedDendroWidth, RGB_WHITE);
				
				//Create a scaling factor to map from dendro matrix position to the dendro png image position
				double heightScale = (double)(intendedDendroHeight-1)/(double)(dendroMatrixHeight-1);
				double widthScale = (double)(intendedDendroWidth-1)/(double)(dendroMatrixWidth-1);
				
				for (int heightPos = 0; heightPos < dendroMatrixHeight; heightPos++){
					for (int widthPos = 0; widthPos < dendroMatrixWidth; widthPos++){
						if (matrix[heightPos][widthPos] > 0) {							
							int y = (int) Math.min(Math.round((double)heightPos*heightScale), intendedDendroHeight-1);
							int x = (int) Math.min(Math.round((double)widthPos*widthScale), intendedDendroWidth-1);
							//If the png is larger than the matrix (happens for small matrices), then for horizontal lines
							//we need to draw more than 1 pixel.  When the widthScale is > 1, then we know we need to draw
							//multiple pixels.  The line segment type is also needed to do this properly.
							LineSegment seg = getSegType(matrix, heightPos, widthPos);
							setTNDendroImageValue(image, x, intendedDendroHeight-(y+1), true, (int)Math.round(widthScale), seg);
						}
					}
				}
				
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnColDendroImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
			return image;
		}	

		/*******************************************************************
		 * METHOD: createTnRowDendroPng
		 *
		 * This method creates a PNG image of the row dendrogram for a 
		 * given heat map. It is used in generating the thumbnail PNG.
		 ******************************************************************/
		private static BufferedImage createTnRowDendroImg(ImportData iData, int intendedDendroHeight, int intendedDendroWidth) {
			BufferedImage image = null;
			try {
				int[][] matrix = iData.rowData.dendroMatrix;
				int dendroMatrixWidth = matrix.length;
				int dendroMatrixHeight = matrix[0].length;

				
				// Create buffered image with specified dimensions
				image = new BufferedImage(intendedDendroWidth, intendedDendroHeight, BufferedImage.TYPE_INT_RGB);

				//Build all white image to draw lines on
		        fillDendroImage(image, intendedDendroHeight, intendedDendroWidth, RGB_WHITE);

				//Create a scaling factor to map from dendro matrix position to the dendro png image position
				double heightScale = (double)(intendedDendroHeight-1)/(double)(dendroMatrixHeight-1);
				double widthScale = (double)(intendedDendroWidth-1)/(double)(dendroMatrixWidth-1);
				
				for (int heightPos = 0; heightPos < dendroMatrixHeight; heightPos++){
					for (int widthPos = 0; widthPos < dendroMatrixWidth; widthPos++){
						if (matrix[widthPos][heightPos] > 0) {
							int y = (int)Math.min(((double)heightPos*heightScale), intendedDendroHeight-1);
							int x = (int)Math.min(((double)widthPos*widthScale), intendedDendroWidth-1);
							//If the png is larger than the matrix (happens for small matrices), then for vertical lines
							//we need to draw more than 1 pixel.  When the heightScale is > 1, then we know we need to draw
							//multiple pixels.  The line segment type is also needed to do this properly.
							LineSegment seg = getSegType(matrix, widthPos, heightPos);
							setTNDendroImageValue(image, intendedDendroWidth-x, y, false, (int)Math.round(heightScale), seg);							
						}
					}
				}
		        
		    } catch (Exception ex) {
				System.out.println("Exception in HeatmapDataGenerator.createTnRowDendroImg: " + ex.toString());  
		        ex.printStackTrace();
		    }
			return image;
		}	

		/*******************************************************************
		 * METHOD: validateConfigJson
		 *
		 * This and following three methods perform a recursive zip of the heatmap directory.  
		 * that the zip file contain a folder at the top level with folder name = heat map name.
		 ******************************************************************/
		private static void zipDirectory(String zipDir, String chmName) throws Exception {
			File directoryToZip = new File(zipDir);
			File rootDir = new File(zipDir.substring(0,Math.max(zipDir.lastIndexOf(File.separator), zipDir.lastIndexOf("/"))));
			String zipFileName = zipDir + FILE_SEP + chmName + ".ngchm";
			List<File> fileList = new ArrayList<File>();
			fileList.add(directoryToZip);
			getAllFiles(directoryToZip, fileList, chmName);
			writeZipFile(rootDir, fileList, zipFileName);
		}

		private static void getAllFiles(File dir, List<File> fileList, String chmName) {
			try {
				File[] files = dir.listFiles();
				for (File file : files) {
					String fileName = file.getName();
					if (!chmName.equals(EMPTY))  { // there are some build files we don't need in the viewer zip file.  At the top level, just zip the heat map folder not other files.
						if (NGCHM_FILES.contains(fileName) || fileName.equals(chmName+" HeatMap.pdf")) {
							fileList.add(file);
						} 
					} else {
						fileList.add(file);
					}
					if (file.isDirectory()) {
						getAllFiles(file, fileList, EMPTY);
					} 
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		private static void writeZipFile(File directoryToZip, List<File> fileList, String zipFileName) {

			try {
				FileOutputStream fos = new FileOutputStream(zipFileName);
				ZipOutputStream zos = new ZipOutputStream(fos);

				for (File file : fileList) {
					if (!file.isDirectory()) { // we only zip files, not directories
						addToZip(directoryToZip, file, zos);
					}
				}
				zos.close();
				fos.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws FileNotFoundException,
		IOException {

			FileInputStream fis = new FileInputStream(file);

			// we want the zipEntry's path to be a relative path that is relative
			// to the directory being zipped, so chop off the rest of the path
			String zipFilePath = file.getCanonicalPath().substring(directoryToZip.getCanonicalPath().length() + 1,
					file.getCanonicalPath().length());
			if (zipFilePath.contains("\\"))
				zipFilePath = zipFilePath.replace("\\", "/");
			ZipEntry zipEntry = new ZipEntry(zipFilePath);
			zos.putNextEntry(zipEntry);

			byte[] bytes = new byte[1024];
			int length;
			while ((length = fis.read(bytes)) >= 0) {
				zos.write(bytes, 0, length);
			}

			zos.closeEntry();
			fis.close();
		}

}
